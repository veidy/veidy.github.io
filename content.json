[{"title":"android 开发之aar——本地文件引用","date":"2017-07-05T07:05:12.000Z","path":"2017/07/05/aar-01/","text":"如果你知道aar文件是个什么东西，直接切到“如何引用”吧 什么是aar文件：官方解释: 我来总结一下:aar首先它是一个后缀为.aar的文件，然后这个文件是在android项目里面使用的，它是一个android库文件，然后它比我们之前使用的.jar文件更强大！！！over~ ###如何生成：首先得创建一个库，继续官方文档走起：example: Next一直到finish一个module就创建好了~ 接下来我在新建的aarlibrary 这个module里面写一个静态方法，然后在app module里面调用 aarlibrary 的module: app的module: 压根找不到这个类，更别提方法了! 因为目前app没有对新建的 aarlibrary 进行依赖！ 官方文档继续走起！但是这都不是这篇文章的重点，这篇文章主要是想分享如何单独引用.aar文件，oh,忘记了我们还没看到.aar文件在哪，说好的如何生成呢！！！不急，先看官网怎么说： 如果希望单独共享 AAR 文件，则可以在 项目名称/模块名称/build/outputs/aar/ 中找到它，也可以通过点击 Build &gt; Make Project 的方式重新生成此文件。 尼玛，如何生成 这么简单 上面绕了一大堆废话! ###如何引用： 第一步:之前怎么导入的.jar文件，现在就怎么导入.aar文件喽! 第二步:在app的build.gradle里面加入下面配置12345repositories &#123;flatDir &#123;dirs &apos;libs&apos; //this way we can find the .aar file in libs folder&#125;&#125; 第三步:在app的build.gradle的dependencies里面加下面配置1compile(name: &apos;aarlibrary-debug&apos;, ext: &apos;aar&apos;) 三步完成！接下来在app项目里面就可以正常使用aarlibrary里面的资源喽~~~~ demo始终是demo,真正在项目中使用时会发现更多的问题NO.1:目前aarlibrary 里面可以写任意代码也可以引用任意资源文件 但是！但是！但是！如果我们的aarlibrary 里面也有依赖另外一个module 如：otherLibrary，在app项目里面却无法调用otherLibrary 里面的内容!!! 怎么办？看完下篇文章《android 开发之aar——本地仓库引用》之后咱们再看这个问题~","tags":[{"name":"aar","slug":"aar","permalink":"http://www.veidy.net/tags/aar/"}]},{"title":"App开启深度链接","date":"2017-06-12T06:58:19.000Z","path":"2017/06/12/deepLinks/","text":"理解 深度链接其实就是一个可以直接打开app或者进入到app某一个落地页的url，直接在浏览器里面打开app oh!不就是之前百度关键词”android 浏览器启动app”吗！！！ 功能实现废话不多说直接上代码！！！android端主要是在Manifest.xml里面配置： &lt;activity android:name=&quot;.BrowserLunchActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt; &lt;data android:host=&quot;blog&quot; android:scheme=&quot;veidy&quot;&gt; &lt;/data&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 在项目里面新建一个BrowserLunchActivity，并在注册的时候配置如上属性。 web端的url就可以直接这样写啦: &lt;a href=&quot;veidy://blog&quot;&gt;点击打开app&lt;/a&gt; OK！深度链接定制成功。实现是ok了，为什么是这么配置呐？首先看看 &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt; 直接看看官网的解释:照着撸吧~然后最重要的是下面data的定义： &lt;data android:host=&quot;blog&quot; android:scheme=&quot;veidy&quot;&gt; &lt;/data&gt; schemeurl之所以能定位到我们的app就是在data里面设置的scheme 如果只设置scheme=”veidy”,在url的href里面写成href=”veidy://“ 一样可能打开我们app host是域名，其实就是一个适当的描述,我们可以自定义,如上我定义一个字符串”blog”,这时在url的href里面写成href=”veidy://blog”,也可以用包名定义如”com.veidy.blog.deeplinks”，那在url的href里面写成href=”veidy://com.veidy.blog.deeplinks” 指定到单独的落地页上面已经实现的深度链接的功能，在url里面打开我们的app，接下来需求实现的是不同的url，跳转到app不通的页面(Activity)如果我要到SecondActivity，就如下配置: &lt;data android:host=&quot;test&quot; android:path=&quot;/appsecond&quot; android:scheme=&quot;veidy&quot;&gt; &lt;/data&gt; 如果我要到ThirdActivity,就如下配置: &lt;data android:host=&quot;test&quot; android:path=&quot;/appthird&quot; android:scheme=&quot;veidy&quot;&gt; &lt;/data&gt; 发现我们用来区分的就是通过path！！！！ps: pathPrefix、pathPattern 一样能实现 传值如果我在跳转到app某个落地页的时候还需要传值呢？很简单了，直接拼在url后面喽。。。&lt;a href=&quot;veidy://test/appthird?key=1&amp;name=veidy&amp;sex=男&quot;&gt;进入到app指定页面ThirdActivity并传递数据 veidy://test/appthird&lt;/a&gt; 然后我们在指定的落地页取值就好啦~~~直拉上debug时的一个图，很清楚","tags":[{"name":"deep-links","slug":"deep-links","permalink":"http://www.veidy.net/tags/deep-links/"},{"name":"web","slug":"web","permalink":"http://www.veidy.net/tags/web/"}]},{"title":"混淆代码恢复","date":"2017-03-09T03:36:02.000Z","path":"2017/03/09/retrace/","text":"proguard 相信已经不再陌生，但是混淆代码恢复估计玩得少。 混淆配置的时候会有这么一段，重要的文件就是 mapping.txt。注释写得很清楚，代码混淆前后的映射。 可能大家都有用过友盟sdk,里面有一个功能就是分析错误，针对每一个版本都会让我们上传一个mapping.txt文件，这样 收集到的错误就不会是混淆之后的代码a.b.c，而是我们真正的包名了~ 怎么做到的呢？一顿资料查找， ReTrace!在我们SDK目录里面就有这个工具。 路径: sdk/tools/proguard/bin/proguardgui.sh 运行后就会打开GUI工具了。 选择左边最下面的ReTrace-&gt;选择apk混淆时生成的mapping.txt文件-&gt;在”Obfuscated stack trace” 里面贴出报错的代码-&gt;点击右下角的ReTrace! 在&quot;De-obfuscated stack trace&quot; 里面就会恢复出真正的源码 代码混淆还不熟悉的童鞋可以阅读下这篇文章Android studio 使用心得(五)—代码混淆和破解apk","tags":[]},{"title":"React Native","date":"2016-04-15T10:04:24.000Z","path":"2016/04/15/rn-001/","text":"","tags":[{"name":"React Native","slug":"React-Native","permalink":"http://www.veidy.net/tags/React-Native/"}]},{"title":"swift学习笔记之网络请求NSURLSession","date":"2016-04-12T07:01:21.000Z","path":"2016/04/12/swift-009/","text":"知识点：1.UILabel多行显示2.NSURLSession get post请求3.异步线程与主线程的切换 效果图： 理解：先说说NSURLSession NSURLSession是iOS7中新的网络接口 没什么可说的了。。。 再提提UILabel的多行显示，UILabel默认只显示两行，所以要想多行显示需要设置 //设置无限换行 mLabelGet?.numberOfLines=0 光设置这个还不够，还需要动态计算Label的高度 mLabelGet?.text=strContent; //根据Label上的内容计算size let newSize:CGSize=(mLabelGet?.sizeThatFits((mLabelGet?.frame.size)!))! //重新设置Label的frame mLabelGet?.frame=CGRect(x: 10, y: 25,width: newSize.width,height: newSize.height) 最后说说子线程通知UI线程 android里面子线程不能直接操作UI线程的东西，ios一样，android里面子线程通知主线程是通过handler来完成的，在ios里面，也是有api能做的 public func dispatch_async(queue: dispatch_queuet, block: dispatch_block_t) 直接看代码吧。。。代码里面是通过URLSession 进行get,post请求 代码块： // // NSURLSessionController.swift // VeidySwiftDemo // // Created by veidy on 16/3/31. // Copyright © 2016年 veidy. All rights reserved. // import Foundation import UIKit import Alamofire class NSURLSessionController: UIViewController { var mLabelGet:UILabel? var mButtonGet:UIButton? var mButtonPost:UIButton? var strContent:String? var mLabelWidth:CGFloat? var mButton_Y:CGFloat=170 override func viewDidLoad() { super.viewDidLoad() self.view.backgroundColor=UIColor.whiteColor() mLabelWidth=CGFloat(self.view.frame.size.width-20) mLabelGet=UILabel(frame:CGRect(x: 10, y: 10, width: mLabelWidth!, height: 100)) mLabelGet?.textColor=UIColor.redColor() mLabelGet?.backgroundColor=UIColor.blueColor() mLabelGet?.font=UIFont.systemFontOfSize(14) //设置无限换行 mLabelGet?.numberOfLines=0 strContent=\"开始xxxggxxxggdgdsgdsgsxxxggdgdsgdsgsxxxggdgdsgdsgsxxxggdgdsgdsgsxxxggdgdsgdsgsxxxggdgdsgdsgsxxxggdgdsgdsgsdgdsgdsgs挑选换行xxxggxxxggdgdsgdsgsxxxggdgdsgdsgsxxxggdgdsgdsgsxxxggdgdsgdsgsxxxggdgdsgdsgsxxxggdgdsgdsgsxxxggdgdsgdsgsdgdsgdsgsxxxggxxxggdgdsgdsgsxxxggdgdsgdsgsxxxggdgdsgdsgsxxxggdgdsgdsgsxxxggdgdsgdsgsxxxggdgdsgdsgsxxxggdgdsgdsgsdgdsgdsgs结束\" mLabelGet?.text=strContent; //根据Label上的内容计算size let newSize:CGSize=(mLabelGet?.sizeThatFits((mLabelGet?.frame.size)!))! //重新设置Label的frame mLabelGet?.frame=CGRect(x: 10, y: 25,width: newSize.width,height: newSize.height) mButton_Y=25+(mLabelGet?.frame.height)!+10 mButtonGet=UIButton(frame: CGRect(x:self.view.frame.width/2-50, y: mButton_Y, width: 100, height: 30)) mButtonGet?.setTitle(\"get请求\", forState: UIControlState.Normal) mButtonGet?.setTitleColor(UIColor.whiteColor(), forState:UIControlState.Normal) mButtonGet?.layer.cornerRadius=6; mButtonGet?.backgroundColor=UIColor.init(red: 71/255, green: 194/255, blue: 73/255, alpha: 1.0) mButtonPost=UIButton(frame: CGRect(x:self.view.frame.width/2-50, y: mButton_Y+40, width: 100, height: 30)) mButtonPost?.setTitle(\"post请求\", forState: UIControlState.Normal) mButtonPost?.setTitleColor(UIColor.whiteColor(), forState:UIControlState.Normal) mButtonPost?.layer.cornerRadius=6; mButtonPost?.backgroundColor=UIColor.init(red: 71/255, green: 194/255, blue: 73/255, alpha: 1.0) self.view.addSubview(mLabelGet!) self.view.addSubview(mButtonGet!) self.view.addSubview(mButtonPost!) mButtonGet?.addTarget(self, action: #selector(NSURLSessionController.sessionGet), forControlEvents: UIControlEvents.TouchUpInside) mButtonPost?.addTarget(self, action: #selector(NSURLSessionController.sessionPOST), forControlEvents: UIControlEvents.TouchUpInside) } //get请求 func sessionGet() { let urlString:String = \"http://www.weather.com.cn/data/sk/101010100.html\" let url:NSURL=NSURL(string: urlString)! //创建请求 let request:NSURLRequest=NSURLRequest(URL: url) //获取SESSION let session=NSURLSession.sharedSession() //异步任务 let dataTask=session.dataTaskWithRequest(request) { (data, response, error) in if error != nil{ print(error?.code) print(error?.description) }else{ let str=NSString(data: data!, encoding: NSUTF8StringEncoding) as! String print(\"服务器返回数据:\"+str) print(NSThread.currentThread()) //异步切到主线程 dispatch_async(dispatch_get_main_queue(), { print(NSThread.currentThread()) self.mLabelGet?.text=str //重新计算label高度 let newSize:CGSize=(self.mLabelGet?.sizeThatFits((self.mLabelGet?.frame.size)!))! self.mLabelGet?.frame=CGRect(x: 10, y: 25,width: newSize.width,height: newSize.height) self.mButton_Y=25+(self.mLabelGet?.frame.height)!+10 self.mButtonGet?.frame=CGRect(x:self.view.frame.width/2-50, y: self.mButton_Y, width: 100, height: 30) self.mButtonPost?.frame=CGRect(x:self.view.frame.width/2-50, y: self.mButton_Y+40, width: 100, height: 30) }) // print(NSThread.currentThread()) } } dataTask.resume() } //post请求 func sessionPOST() { let urlString:String = \"http://v.juhe.cn/weixin/query\" let url:NSURL=NSURL(string: urlString)! //创建请求 let request:NSMutableURLRequest=NSMutableURLRequest(URL: url) //设置请求方式 request.HTTPMethod=\"POST\" //设置请求参数 let body=\"pno=1&ps=15&key=760a19928b2dad2e80083c19d289a566\" //编码post数据 let postdata=body.dataUsingEncoding(NSASCIIStringEncoding) //HTTPBody request.HTTPBody=postdata print(\"请求url\"+(request.URL?.absoluteString)!) //获取SESSION let session=NSURLSession.sharedSession() //异步任务 let dataTask=session.dataTaskWithRequest(request) { (data, response, error) in if error != nil{ print(error?.code) print(error?.description) }else{ let str=NSString(data: data!, encoding: NSUTF8StringEncoding) as! String print(\"服务器返回数据:\"+str) } } dataTask.resume() } }","tags":[{"name":"NSURLSession","slug":"NSURLSession","permalink":"http://www.veidy.net/tags/NSURLSession/"},{"name":"UILabel","slug":"UILabel","permalink":"http://www.veidy.net/tags/UILabel/"}]},{"title":"我不是程序猿-《小幸运》","date":"2016-04-02T06:12:31.000Z","path":"2016/04/02/video-001/","text":"敲代码改BUG,加班单身狗，背程序猿要背的包包，看程序猿应该看的电影，听程序猿适合听的歌，总之做程序猿该做的事，你才能说自己是程序猿 我不是程序猿 猿在这","tags":[{"name":"视频","slug":"视频","permalink":"http://www.veidy.net/tags/视频/"}]},{"title":"swift学习笔记之UIImageView","date":"2016-03-31T06:52:29.000Z","path":"2016/03/31/swift-008/","text":"知识点1.UIImage2.NSURLSession3.UIImageView添加点击事件 效果图 唠叨UIImageView 要显示图片就必须得用到UIImage，和android里面的ImageView 和Bitmap类似 //加载本地资源图片 mImageView.image = UIImage.init(named: \"icon\") 会不会太简单，“icon”就是图片的名字，但是它放在哪里呢 添加图片到资源文件： 点击Assets.xcassets,然后把要放入的图片直接往右边拖进去就好了 加载本地图片太简单，再尝试下加载网络，用到系统API-&gt; NSURLSession NSURLSession是iOS7中新的网络接口 就是封装的一套网络请求，可以请求基本的接口返回数据，也可以下载文件，也可以上传文件，同步，异步皆可。。。完美，比安卓的api要不要好太多 这里先看一下怎么用这个加载图片，后面再详细了解NSURLSession吧 //创建NSURL对象 let myimgUrl=NSURL(string: \"http://f.hiphotos.baidu.com/image/pic/item/b17eca8065380cd70c5150cba444ad345982814d.jpg\") //创建请求对象 let request:NSURLRequest=NSURLRequest(URL: myimgUrl!) //获取NSURLSession let mySession=NSURLSession(configuration: NSURLSessionConfiguration.defaultSessionConfiguration()) //进行一个异步任务 let dataTask=mySession.dataTaskWithRequest(request) { (imagedata, response, error) -> Void in //UIImageView展示 mImage.image=UIImage(data: imagedata!) } //启动任务 dataTask.resume() 上面的代码有一个bug,如果使用上面的代码去加载网络图片，会发现图片要加载很久才显示，为什么呢，线程阻塞！ //进行一个异步任务 let dataTask=mySession.dataTaskWithRequest(request) { (imagedata, response, error) -> Void in //UIImageView展示 mImage.image=UIImage(data: imagedata!) } 这个方法其实是处于子线程了，和android一线，子线程不能更新UI线程的东西。。。向我们IOS开发大神求救得到一种方法，比我们android的handler不要好太多.... //当前处于子线程，需要回到主线程才能更新UI dispatch_async(dispatch_get_main_queue(), { mImage.image=UIImage(data: imagedata!) }) 如何判断当前处于子线程还是主线程： print(NSThread.currentThread()) 打印出的name为main就是主线程！ 代码块 import Foundation import UIKit class ImageSwift: UIViewController { override func viewDidLoad() { super.viewDidLoad() self.view.backgroundColor = UIColor.whiteColor() let mImageView=UIImageView() mImageView.frame=CGRectMake(0, 25, 300, 450) //加载本地资源图片 mImageView.image = UIImage.init(named: \"icon\") self.view.addSubview(mImageView) //添加交互 mImageView.userInteractionEnabled=true; let tap=UITapGestureRecognizer.init(target: self, action: #selector(ImageSwift.imgtap)) mImageView.addGestureRecognizer(tap) //加载网络图片 showNetImg(mImageView) } func imgtap(){ let mVC=UITableViewSwift() self.presentViewController(mVC, animated: false, completion: nil) } //异步加载网络图片 func showNetImg(mImage:UIImageView){ //创建NSURL对象 let myimgUrl=NSURL(string: \"http://f.hiphotos.baidu.com/image/pic/item/b17eca8065380cd70c5150cba444ad345982814d.jpg\") //创建请求对象 let request:NSURLRequest=NSURLRequest(URL: myimgUrl!) //获取NSURLSession let mySession=NSURLSession(configuration: NSURLSessionConfiguration.defaultSessionConfiguration()) //进行一个异步任务 let dataTask=mySession.dataTaskWithRequest(request) { (imagedata, response, error) -> Void in //当前处于子线程，需要回到主线程才能更新UI dispatch_async(dispatch_get_main_queue(), { mImage.image=UIImage(data: imagedata!) }) } //启动任务 dataTask.resume() } }","tags":[{"name":"NSURLSession","slug":"NSURLSession","permalink":"http://www.veidy.net/tags/NSURLSession/"},{"name":"UIImageView","slug":"UIImageView","permalink":"http://www.veidy.net/tags/UIImageView/"}]},{"title":"swift学习笔记之数据持久化(属性列表)","date":"2016-03-30T08:48:20.000Z","path":"2016/03/30/swift-007/","text":"知识点沙箱NSUserDefaultsUITextField基本使用软键盘的关闭静态类 效果图 理解这里只写写有关存储的属性列表，关于UITextField的看代码的注释吧 ios数据持久化方式有: 属性列表，对象归档，SQLite,Core Data 沙箱 沙箱目录是一种数据安全策略，ios有一套完整的数据安全体系，ios应用程序只能访问自己的目录，这个目录称为沙箱目录。 沙箱目录里面有几个特定的文件夹 |---Documents | |---Library | ---Caches | ---Preferences |---tmp 这几个文件夹需要注意的是tmp文件夹，其它文件夹里面的数据都不会自己清空，除非程序卸载掉，但是tmp文件夹里面的内容是程序每次重启都会清空的 //获取Document目录 let documentsDirectory = NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory.DocumentDirectory,NSSearchPathDomainMask.UserDomainMask, true) let paths = documentsDirectory[0] as String //获取Library目录 let paths = NSSearchPathForDirectoriesInDomains( NSSearchPathDirectory.LibraryDirectory,NSSearchPathDomainMask.UserDomainMask, true)[0] as String //获取Cache目录 程序退出不会清空 let paths=NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory.CachesDirectory, NSSearchPathDomainMask.UserDomainMask, true)[0] as String //获取tmp文件夹路径 let paths=NSTemporaryDirectory() .plist文件理解为就是一个xml文件，键值对的形式存储数据，但是对数据类型有限制了，只能是以下数据类型 NSArray;NSMutableArray;NSDictionary;NSMutableDictionary;NSData;NSMutableData;NSString;NSMutableString;NSNumber;NSDate; 创建一个plist文件，存放 NSDictionary，调用writeToFile(path, atomically: true) //新建一个plist文件 Helper.createPlistFile(\"veidyplist\") //创建一个plist文件 static func createPlistFile(name:String){ let dict = NSDictionary.init(object: \"plist\", forKey: \"name\") let path=DocumentsPath()+\"/\"+name+\".plist\" dict.writeToFile(path, atomically: true) } 打印出路径，前往文件夹就能找到这个plist文件 读取plist let dic:NSDictionary = NSDictionary.init(contentsOfFile: Helper.DocumentsPath()+”/veidyplist.plist”)! let value = dic.valueForKey(“name”) if (value != nil) { print(“VALUE=”+(value as! String)) } NSUserDefaultsNSUserDefaults也是一个plist文件,它在Library/Preferenes 下面其实我们一般使用这个来存储一些配置信息就够用了，不需要自己再创建一个plist文件 存储使用： let userDefault=NSUserDefaults.standardUserDefaults() userDefault.setObject(“uservalue”, forKey: “key”) //同步 userDefault.synchronize() 获取存储数据： let userDefault=NSUserDefaults.standardUserDefaults() let value = username?.objectForKey(“key”) as! String 全文下来还没提到 属性列表 这四个字。。。其实就是指的plist文件了 静态类和java 没什么区别， static func name()，然后直接用类名调方法 代码块这里是以一个登录界面做为例子。用户进入登录界面，先帮用户查询是否有过登录记录，有则直接加载显示，没有则在用户点击登录的时候保存以便下次可以读取 先贴出一个静态帮助类Helper.swift // // Helper.swift // VeidySwiftDemo // // Created by veidy on 16/3/29. // Copyright © 2016年 veidy. All rights reserved. // import Foundation class Helper: NSObject { static func getHomePath()->String{ let homepath=NSHomeDirectory() return homepath } //Documents目录 苹果建议将程序中建立的或在程序中浏览到的文件数据保存在该目录下，iTunes备份和恢复的时候会包含此目录 static func DocumentsPath()->String{ let documentsDirectory = NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory.DocumentDirectory,NSSearchPathDomainMask.UserDomainMask, true) let paths = documentsDirectory[0] as String print(\"paths=\"+paths) return paths } //Library目录 这个目录下有2个子目录：Caches缓存 , Preferences偏好设置,不应该直接创建偏好设置文件而使用NSUserDefaults类 static func LibraryPath()->String{ let paths = NSSearchPathForDirectoriesInDomains( NSSearchPathDirectory.LibraryDirectory,NSSearchPathDomainMask.UserDomainMask, true)[0] as String return paths } //Cache目录 程序退出不会清空 static func cachePath()->String{ let paths=NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory.CachesDirectory, NSSearchPathDomainMask.UserDomainMask, true)[0] as String return paths } //tmp目录 存放临时文件，程序再次启动会清空 static func tmpPath()->String{ let paths=NSTemporaryDirectory() return paths } //创建一个文件夹 static func createFileDirectory(path:String){ let fileManager=NSFileManager.defaultManager() if !fileManager.fileExistsAtPath(path){ print(\"创建文件夹\") try! fileManager.createDirectoryAtPath(path, withIntermediateDirectories: true, attributes: nil) }else{ print(\"文件夹已经存在\") } } //创建一个plist文件 static func createPlistFile(name:String){ let dict = NSDictionary.init(object: \"plist\", forKey: \"name\") let path=DocumentsPath()+\"/\"+name+\".plist\" dict.writeToFile(path, atomically: true) } } 登录界面 // // LoginController.swift // VeidySwiftDemo // // Created by veidy on 16/3/29. // Copyright © 2016年 veidy. All rights reserved. // import Foundation import UIKit class LoginController: UIViewController,UITextFieldDelegate { var mUsername:UITextField? var mPassword:UITextField? var mLogin:UIButton? override func viewDidLoad() { super.viewDidLoad() self.view.backgroundColor=UIColor.whiteColor() initDirConfig() mUsername=UITextField.init(frame: CGRect.init(x: (self.view.frame.size.width/2)-130, y: 100, width: 260, height: 30)) mUsername?.backgroundColor=UIColor.whiteColor() //设置提示语 mUsername?.placeholder=\"手机号\" //自定义字体 // mUsername?.font=UIFont.init(name: \"STHeitiSC-Medium\", size: 14) //使用系统字体 mUsername?.font=UIFont.systemFontOfSize(14) mUsername?.textAlignment=NSTextAlignment.Center //自定义颜色 r:71 g:194 b:73 mUsername?.textColor=UIColor.init(red: 175/255, green: 175/255, blue: 175/255, alpha: 1.0) //设置边框样式 mUsername?.borderStyle=UITextBorderStyle.RoundedRect //设置弹出键盘样式 mUsername?.keyboardType=UIKeyboardType.PhonePad; mUsername?.clearButtonMode=UITextFieldViewMode.WhileEditing; mPassword=UITextField.init(frame:CGRect.init(x: (self.view.frame.size.width/2)-130, y: 140, width: 260, height: 30) ) mPassword?.backgroundColor=UIColor.whiteColor() mPassword?.placeholder=\"密码\" mPassword?.textAlignment=NSTextAlignment.Center mPassword?.textColor=UIColor.init(red: 175/255, green: 175/255, blue: 175/255, alpha: 1.0) mPassword?.borderStyle=UITextBorderStyle.RoundedRect //密码输入 mPassword?.secureTextEntry=true; //右边出现一个可清空的按钮 mPassword?.clearButtonMode=UITextFieldViewMode.WhileEditing; mPassword?.delegate=self; mLogin=UIButton.init(frame: CGRect.init(x: (self.view.frame.size.width/2)-130, y:180, width: 260, height: 30) ) mLogin?.frame=CGRect.init(x: (self.view.frame.size.width/2)-130, y:180, width: 260, height: 30) mLogin?.backgroundColor=UIColor.init(red: 71/255, green: 194/255, blue: 73/255, alpha: 1.0) mLogin?.setTitle(\"登录\", forState: UIControlState.Normal) //设置圆角 mLogin?.layer.cornerRadius=6 mLogin?.highlighted=true //设置文字大小 mLogin?.titleLabel?.font=UIFont.systemFontOfSize(14) mLogin?.addTarget(self, action: #selector(loginOnclick), forControlEvents: .TouchUpInside) self.view.addSubview(mUsername!) self.view.addSubview(mPassword!) self.view.addSubview(mLogin!) readInfo() } func textFieldDidBeginEditing(textField: UITextField) { print(\"监听 textFieldDidBeginEditing 点击输入框\") } func textFieldDidEndEditing(textField: UITextField) { print(\"监听 textFieldDidEndEditing 离开输入框\") } func loginOnclick(){ //首先关闭软键盘 self.view.endEditing(true) saveInfo() let UITableVC=UITableViewSwift() self.presentViewController(UITableVC, animated: true, completion: nil) } //放弃第一响应者 func textFieldShouldReturn(textField: UITextField) -> Bool{ print(\"textFieldShouldReturn\") textField.resignFirstResponder() return true } override func viewWillAppear(animated: Bool){ //注册通知 } override func viewWillDisappear(animated: Bool) { //解除通知 } //保存配置信息 Preference func saveInfo(){ let userDefault=NSUserDefaults.standardUserDefaults() userDefault.setObject(mUsername?.text, forKey: \"username\") userDefault.setObject(mPassword?.text, forKey: \"password\") //同步 userDefault.synchronize() } //读取配置信息 Preference func readInfo(){ let userDefault=NSUserDefaults.standardUserDefaults() let username=userDefault.objectForKey(\"username\") let password=userDefault.objectForKey(\"password\") if (username != nil){ mUsername?.text=username as? String } if (password != nil) { mPassword?.text=password as? String } } func initDirConfig(){ print(\"getHomePath() \"+Helper.getHomePath()) print(\"DocumentsPath() \"+Helper.DocumentsPath()) print(\"LibraryPath() \"+Helper.LibraryPath()) print(\"初始化目录。。。\") //新建一个plist文件 Helper.createPlistFile(\"veidyplist\") let dic:NSDictionary = NSDictionary.init(contentsOfFile: Helper.DocumentsPath()+\"/veidyplist.plist\")! let value = dic.valueForKey(\"name\") if (value != nil) { print(\"VALUE=\"+(value as! String)) } } }","tags":[{"name":"NSUserDefaults","slug":"NSUserDefaults","permalink":"http://www.veidy.net/tags/NSUserDefaults/"}]},{"title":"swift学习笔记之自定义UITableViewCell","date":"2016-03-25T08:56:23.000Z","path":"2016/03/25/swift-006/","text":"知识点：UITableView 自定义cellcell高度自定义 效果图: 唠叨: 第一次弄这个自定义cell…宝宝心里苦啊。。。。 为什么要自定义cell？因为系统的cell就一个label和一个image，在项目里面是不够的。 自定义cell首先得新建一个类，继承UITableViewCell，并重写init方法 class JokeCell: UITableViewCell { //必须重写 required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) } } 然后就是定义控件布局我要放两个Label,那就定义两个Label var mContent:UILabel? var mTime:UILabel? 然后，我们要在哪里初始化这些控件呢？1.先定义一个方法setUI()，把初始化这些东西都在setUI()里面处理 func setUI(){ if(self.mContent==nil){ self.mContent=UILabel() self.mContent!.frame=CGRect.init(x: 10, y: 0, width: 100, height: 50) self.addSubview(self.mContent!) } if(self.mTime==nil){ self.mTime=UILabel() self.mTime!.frame=CGRect.init(x: 0, y: 60, width: self.frame.size.width, height: 50) mTime!.textAlignment=NSTextAlignment.Right mTime!.textColor=UIColor.redColor() self.addSubview(mTime!) } //50+10+50 ==110 ,所以cell高度可以设置为110 } 当我们在设置控件坐标的时候就能算出这个cell的高度了。mContent Y的起点为0，高度为50，mTime的Y为60，高度为50,所以就是这个cell的高度就是 60+50=110。 在哪里设置cell的高度呢？目前我知道的有两种方法，第一种好简单，回到UIViewController //统一设置 tableView 行高 self.tableView?.rowHeight=110; 第二种也很好玩: 在UITableViewDelegate里面找到一个方法 func tableView(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -> CGFloat 重写ok 这种更适合在cell有多种布局的时候，最常用的就是聊天的界面。。。有单个的文字cell，有单个的图片cell 好了，回到前面讲的setUI()，在哪里调用这个方法呢？ 我找到一个好地方，在自定义cell里面重写另外一个方法 //可选重写，但是建议这么玩，把UI初始化放里面更方便 override init(style: UITableViewCellStyle, reuseIdentifier: String?) { super.init(style: style, reuseIdentifier: reuseIdentifier) setUI() } setData(joke:Joke)把setUI()放在这个里面，不用再管了。然后再定义一个赋值的方法setData(joke:Joke) //设置数据 func setData(joke:Joke){ mTime!.text=joke.time mContent!.text=joke.content } 那么setData(joke:Joke)方法我们在哪里调呢？？？ 这样自定义的JokeCell就搞定了不用管了，只有一个setData()被调用了。 怎么用JokeCell回到UIViewController， UITabView 初始化什么的就过了，可以看上一篇文章swift学习笔记之UITableView，但是使用自定义的时候有两个地方需要注意 第一个地方是cell注册的时候： self.tableView!.registerClass(JokeCell.self, forCellReuseIdentifier: “swift_cell”) 要用哪个cell就注册哪个，这里一定要记得改啊，别一直用UITableViewCell.self 第二个注意的地方当然就是 func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell 这个方法里面取cell的时候 //如果是自定义cell，记得在注册的时候改成自定义cell。 let cell=tableView.dequeueReusableCellWithIdentifier(id_cell,forIndexPath: indexPath) as? JokeCell swift语法真是骚。。。 as? JokeCell 这样我们就拿到了自定义cell JokeCell. 接着就是给cell赋值了 //记得取的时候 as ? JokeCell,不要问我为什么，宝宝心里苦 cell!.setData(data) command+R 搞定收工！ 代码块：实体Joke // // Joke.swift // VeidySwiftDemo // // Created by veidy on 16/3/21. // Copyright © 2016年 veidy. All rights reserved. // import Foundation class Joke: NSObject { var content:String?; var url:String?; var time:String?; } 自定义cell JokeCell // // JokeCell.swift // VeidySwiftDemo // // Created by veidy on 16/3/25. // Copyright © 2016年 veidy. All rights reserved. // import UIKit class JokeCell: UITableViewCell { var mContent:UILabel? var mTime:UILabel? //必须重写 required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) } //可选重写，但是建议这么玩，把UI初始化放里面更方便 override init(style: UITableViewCellStyle, reuseIdentifier: String?) { super.init(style: style, reuseIdentifier: reuseIdentifier) setUI() } //初始化UI func setUI(){ if(self.mContent==nil){ self.mContent=UILabel() self.mContent!.frame=CGRect.init(x: 10, y: 0, width: 100, height: 50) self.addSubview(self.mContent!) } if(self.mTime==nil){ self.mTime=UILabel() self.mTime!.frame=CGRect.init(x: 0, y: 60, width: self.frame.size.width, height: 50) mTime!.textAlignment=NSTextAlignment.Right mTime!.textColor=UIColor.redColor() self.addSubview(mTime!) } //50+10+50 ==110 ,所以cell高度可以设置为110 } //设置数据 func setData(joke:Joke){ mTime!.text=joke.time mContent!.text=joke.content } override func setSelected(selected: Bool, animated: Bool) { super.setSelected(selected, animated: animated) } } UITableViewSwift.swift // // UITableViewSwift.swift // VeidySwiftDemo // // Created by veidy on 16/3/21. // Copyright © 2016年 veidy. All rights reserved. // import Foundation import UIKit class UITableViewSwift: UIViewController,UITableViewDelegate,UITableViewDataSource { var tableView:UITableView? //定义一个集合 var jokeList = [Joke](); override func loadView() { super.loadView() } override func viewDidLoad() { super.viewDidLoad() self.view.backgroundColor = UIColor.whiteColor() for index in 0...15{ print(index) let joke:Joke=Joke() joke.time=\"2016-03-2\\(i)\" joke.content=\"swift_ios_\\(i)\"; self.jokeList.append(joke) } self.tableView=UITableView(frame: self.view.frame, style: .Grouped) //指定代理对象 self.tableView!.delegate=self //指定代理对象 self.tableView!.dataSource=self; self.tableView!.registerClass(JokeCell.self, forCellReuseIdentifier: \"swift_cell\") self.view.addSubview(self.tableView!) //统一设置 tableView cell 高度 self.tableView?.rowHeight=110; } //UITableViewDataSource 委托回调方法 必须需要实现的方法 , 可以理解为android 里面BaseAdapter 的 getView方法 func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell{ let id_cell=\"swift_cell\" //根据位置取到joke 相当于android里面的getItem(int position) let data=self.jokeList[indexPath.row] //通过id去取cell，这样的做法和android 里面的ViewHoler类似功能 //如果是自定义cell，记得在注册的时候改成自定义cell。 let cell=tableView.dequeueReusableCellWithIdentifier(id_cell, forIndexPath: indexPath) as? JokeCell print(\"\\(indexPath.row)\"+data.content!) //记得取的时候语 as ? JokeCell,不要问我为什么，宝宝心里苦 cell!.setData(data) return cell!; } //UITableViewDataSource 必须需要实现的方法 可以理解为android 里面BaseAdapter 的 getcount方法 func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -> Int{ return self.jokeList.count; } //UITableViewDelegate 可以实现方法 cell点击事件，相当于android 里面listview的 onItemClick方法 func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath){ let joke=self.jokeList[indexPath.row] print(\"点击 ：\"+joke.content!) } //动态计算cell高度 // func tableView(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -> CGFloat{ // // return 110； // } }","tags":[{"name":"UITableViewCell","slug":"UITableViewCell","permalink":"http://www.veidy.net/tags/UITableViewCell/"}]},{"title":"520-程序员的浪漫表达方式","date":"2016-03-25T03:46:13.000Z","path":"2016/03/25/veidy-002/","text":"本文由 程序员的资料库 整理! 下面是整理自Quora社区回答的积攒最高的程序员的浪漫表达方式。为了保持原味性，有些简短的就在就保留英文原文。 Question 我刚从一个我喜欢的、却还无法得到她的心的女孩那里获得一个灵感，因此我提出了这个问题。她是我的源之泉。Sorry for the bugs. Blame her!我不知道这是否有效，但是我真的没法集中注意力写代码了，都是因为她。所以，我想听听大家喜欢的一些有关程序员浪漫编程的引用。 1.I always thought love was an abstract class until you made an instance of it. (我一直以为爱是一个抽象的类，直到你实例化了它） 2.You and svn are the only things that ill commit to 3.SELECT * FROM World WHERE “Someone” LIKE ‘%You%’ （SQL查询语句） 4.You are the {CSS} to my {/HTML} 5.while无限循环 6. 7.//Love you a lot while (i&lt;3) you++; 英文地址：Are-there-any-romantic-programming-programmer-quotes","tags":[]},{"title":"swift学习笔记之UITableView","date":"2016-03-23T01:57:59.000Z","path":"2016/03/23/swift_005/","text":"UITableView的简单使用 一、知识点:UITableView集合for循环使用 二、效果图： 三、我的理解1.UITabView和android里面的ListView相似，当然功能比ListViw强大得多，比Recyclerview也要厉害. 2.UITableViewDataSource 和 UITableViewDelegate 协议和委托代理回调，这是ios开发里面非常重要的一个东西(之前弄OC的时候ios开发的同事跟我这样说)，swift 里面的协议其实和android java里面的接口 功能类似，重要！所以有关协议和委托代理 的使用 准备单独整理成一篇文章 3.在使用UITabView的时候，controller必须要继承UITableViewDataSource当你继承UITableViewDataSource的时候xcode会提示错误，因为需要我们实现其必须要实现的方法，进入源码可以看到有两个 @available(iOS 2.0, *) public func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -> Int 这个方法可以理解为android 里面BaseAdapter 的 getcount方法,不用多说，直接返回集合的大小即可 @available(iOS 2.0, *) public func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell 这个方法可以理解为android 里面BaseAdapter 的 getView方法 tip:如何知道协议的哪些方法必须要实现：public前面并没有加上 optional 就说明是必须要实现的。(这一点还是没有java的ide做得好，必须要实现的方法没实现快捷键会立刻实现) 4.demo中我还继承了一个UITableViewDelegate类，委托代理，看源码发现也是继承NSObjectProtocol，也可以理解为是一个协议(先这么理解吧)，如果要实现列表的cell点击事件，就得继承UITableViewDelegate，然后实现其一个方法 optional public func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) 这个方法和android 里面的onItemClick 类似 public void onItemClick(AdapterView parent, View view, int position, long id) 5.? 和 ！ 很有意思的两个东西？ 当我们声明一个变量的时候，我们并不确定给其初始化的时候就可以这么干如： var tableView:UITableView? 声明一个tableView,如果var tableView:UITableView 这样声明会报错，加上？就不报错了。为什么呢？ Swift语言使用var定义变量，但和别的语言不同，Swift里不会自动给变量赋初始值，也就是说变量不会有默认值，所以要求使用变量之前必须要对其初始化。如果在使用变量之前不进行初始化就会报错 为什么加上？就不报错了，这里又得提到swift里面的一个新东西Optional ，这是个神马玩意儿，看源码发现就是一个enum！！！ public enum Optional : _Reflectable, NilLiteralConvertible { case None case Some(Wrapped) } var tableView:UITableView? 就是 var tableView: Optional 这句话我们正确的解读是：声明了一个Optional类型值，它可能包含一个UITableView值，也可能什么都不包含。本来是声明一个UITabView变成了声明了一个Optional类型。 一旦声明为Optional的，如果不显式的赋值就会有个默认值nil，所以就不报错啦！ ！这个东西就是非空判断 self.tableView!.delegate=self 表示我的tableView非空的 ####### 关于？和！暂时就这样理解了，以后再单独整理一篇文章深入了解 6.for循环遍历 swift 里面的for循环有两种遍历方式，一看便知道区别 第一种： for index in 0...15{ print(index) let joke:Joke=Joke() joke.content=\"swift_ios_\\(index)\"; self.jokeList.append(joke) } 打印出: 0123456789101112131415 等于集合大小为 16 第二种： 1234567for var i=0;i&lt;15;i++ &#123; print(i) let joke:Joke=Joke() joke.content=&quot;swift_ios_\\(i)&quot;; self.jokeList.append(joke) &#125; 打印出： 01234567891011121314 等于集合大小为 15 区别显而易见了吧。 四、代码块Joke 是我自定义的一个实体 class Joke: NSObject { var content:String?; var url:String?; } 由于莫名的排版问题，我先把给集合的循环赋值贴出来 //初始化数据for var i=0; i&lt;15; i++ { let joke:Joke=Joke()joke.content=”swiftios(i)”;self.jokeList.append(joke) } // // UITableViewSwift.swift // VeidySwiftDemo // // Created by veidy on 16/3/21. // Copyright © 2016年 veidy. All rights reserved. // import Foundation import UIKit class UITableViewSwift: UIViewController,UITableViewDelegate,UITableViewDataSource { var tableView:UITableView? //定义一个集合 var jokeList = [Joke](); override func loadView() { super.loadView() } override func viewDidLoad() { super.viewDidLoad() self.view.backgroundColor = UIColor.whiteColor() for index in 0...15{ print(index) let joke:Joke=Joke() joke.content=\"swift_ios_\\(index)\"; self.jokeList.append(joke) } print(\"第一种循环遍历后 count=\\(self.jokeList.count)\") //清空数组 self.jokeList.removeAll(); print(\"清空之后,count=\\(self.jokeList.count)\") //初始化数据 //... print(\"第二种循环遍历后 count=\\(self.jokeList.count)\") self.tableView=UITableView(frame: self.view.frame, style: .Grouped) //指定代理对象 self.tableView!.delegate=self //指定代理对象 self.tableView!.dataSource=self; self.tableView!.registerClass(UITableViewCell.self, forCellReuseIdentifier: \"swift_cell\") self.view.addSubview(self.tableView!) } //UITableViewDataSource 委托回调方法 必须需要实现的方法 , 可以理解为android 里面BaseAdapter 的 getView方法 func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell{ let id_cell=\"swift_cell\" //通过id去取cell，这样的做法和android 里面的ViewHoler类似功能 //注意这里之所以能取是前面先注册过 self.tableView!.registerClass(UITableViewCell.self, forCellReuseIdentifier: \"swift_cell\") let cell=tableView.dequeueReusableCellWithIdentifier(id_cell, forIndexPath: indexPath) //根据位置取到joke 相当于android里面的getItem(int position) let data=self.jokeList[indexPath.row] //给textLabel赋值 cell.textLabel?.text=data.content return cell; } //UITableViewDataSource 必须需要实现的方法 可以理解为android 里面BaseAdapter 的 getcount方法 func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -> Int{ return self.jokeList.count; } //UITableViewDelegate 可以实现方法 cell点击事件，相当于android 里面listview的 onItemClick方法 func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath){ let joke=self.jokeList[indexPath.row] print(\"点击 ：\"+joke.content!) } } 显然，这只是简单的使用UITableView,真正项目中是不够的，下一遍文章准备记录如何使用自定义cell。","tags":[{"name":"UITableView","slug":"UITableView","permalink":"http://www.veidy.net/tags/UITableView/"}]},{"title":"程序出错后，程序员给测试人员的20条高频回复","date":"2016-03-21T07:07:04.000Z","path":"2016/03/21/veidy-01/","text":"本文由 伯乐在线 - 黄利民 翻译 编者按：程序员和软件测试员之间的关系无须多言。这些经典回复是国外程序员总结分享的，“全球通用”。 “That’s weird…” 很奇怪…… “It’s never done that before.” 以前没这样过的。 “It worked yesterday.” 昨天还好好的。 “How is that possible?” 那怎么可能？（怎么会出问题？） “It must be a hardware problem.” 这一定是硬件问题。 “What did you type in wrong to get it to crash?” 你输入什么东西后才崩溃的？ “There is something funky in your data.” 你的数据有问题。 “I haven’t touched that module in weeks!” 我好几个礼拜没动那个程序了！ “You must have the wrong version.” 你一定在用错误的版本。 “It’s just some unlucky coincidence.” 这只是凑巧。 “I can’t test everything!” 我无法测试所有东西。（我的机器环境下，无法测试所有的可能情况。） “THIS can’t be the source of THAT.” “这”不可能是问题的原因。 “It works, but it hasn’t been tested.” 程序能用，不过还没有测试。 “Somebody must have changed my code.” 一定有人改了我的代码。 “Did you check for a virus on your system?” 你的电脑扫描病毒了么？ “Even though it doesn’t work, how does it feel? 即便程序不行了，（你觉得）程序写得如何？ “You can’t use that version on your system.” 你不能在你系统上使用那个版本的程序。（程序版本和系统有冲突。） “Why do you want to do it that way?” 你怎么会想着那样操作啊？ “Where were you when the program blew up?” 程序崩溃时，你在做什么呢？（做了哪些操作？） 第1条会是什么？猜猜看吧！:) _ “It works on my machine” 在我机器上好好的！！！（潜台词：怎么在你那就出问题了呢！！！） 编者后话 虽然已经远离编程，但经常还是会用到第20、19条，当然也不会“错过”第1条。各位看过之后，不知你都用上了哪几条哦~","tags":[]},{"title":"swift学习笔记之界面之间的跳转","date":"2016-03-11T07:16:54.000Z","path":"2016/03/11/swift_004/","text":"Controller之间的跳转一、知识点： 1.api:presentViewController() , dismissViewControllerAnimated() 二、demo场景 A controller 上有一个按钮，点击按钮后跳转到B controller上，B controller上有一个标签，点击标签回退到A controller 三，代码 A controller 核心代码： //button点击响应方法，推出SecondViewController（）func btnOnClick(button:UIButton){ let VC=SecondViewController() //推出新的Controller self.presentViewController(VC, animated: false, completion: nil)} B controller 上的Label点击返回上一个controller 核心代码 func tapLabel(){ //关掉当前dismissViewController self.dismissViewControllerAnimated(false, completion: nil)} //数据传递，待续。。。","tags":[{"name":"presentViewController","slug":"presentViewController","permalink":"http://www.veidy.net/tags/presentViewController/"},{"name":"dismissViewControllerAnimated","slug":"dismissViewControllerAnimated","permalink":"http://www.veidy.net/tags/dismissViewControllerAnimated/"}]},{"title":"swift学习笔记之UILabel(二)","date":"2016-03-01T10:06:21.000Z","path":"2016/03/01/swift_003/","text":"UILabel添加点击事件一.知识点 1.UITapGestureRecognizer 二.demo场景 点击UILabel 响应自定义方法 tapLabel()， tapLabel()里面输出日志打印 三.代码class SecondViewController :UIViewController {override func viewDidLoad() { super.viewDidLoad() let mLabel:UILabel=UILabel.init(frame: CGRectMake(100,100, 100, 30)) mLabel.text=“点我” mLabel.textAlignment=NSTextAlignment.Center mLabel.backgroundColor=UIColor.redColor() //用户交互功能打开状态 mLabel.userInteractionEnabled=true //点击事件 let tap = UITapGestureRecognizer.init(target: self, action: Selector.init(“tapLabel”)) //绑定tap mLabel.addGestureRecognizer(tap) self.view.addSubview(mLabel)}//定义方法，mLabel点击后调用此方法func tapLabel(){ print(“tap the label”)}}","tags":[{"name":"UILabel","slug":"UILabel","permalink":"http://www.veidy.net/tags/UILabel/"},{"name":"UITapGestureRecognizer","slug":"UITapGestureRecognizer","permalink":"http://www.veidy.net/tags/UITapGestureRecognizer/"}]},{"title":"Swift学习笔记之UIButton(一)","date":"2016-02-12T15:12:40.000Z","path":"2016/02/12/swift_02/","text":"一、知识点：1.全局变量的定义2.UIButton添加点击事件3.函数定义 二、效果图： 三、代码： import UIKit //定义全局变量 let mLabel:UILabel=UILabel(); class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. //常量定义用let 变量定义用var //let mLabel:UILabel=UILabel(); //设置显示文字 字符串和字符串可以直接用+ 拼接，字符串和int 其它类型可以用 \\() 如下，把2016放在小括号里面即可 mLabel.text=\"veidy\"+\"开始了\\(2016)年的第一次swift 开发\" //设置label背景颜色 mLabel.backgroundColor=UIColor.redColor() //设置文字颜色 mLabel.textColor=UIColor.whiteColor() //设置文字剧中对齐 mLabel.textAlignment=NSTextAlignment.Center //定义坐标位置 label大小 mLabel.frame=CGRect(x: 0, y: 20, width: self.view.frame.size.width, height: 50) //添加到view 显示，没有这一句，UI上不会显示 self.view.addSubview(mLabel) let mButton:UIButton=UIButton() mButton.frame=CGRect(x: 10, y: 80, width: 200, height: 50) mButton.backgroundColor=UIColor.redColor() mButton.setTitle(\"按钮\", forState: .Normal) mButton.setTitle(\"按钮按下\", forState: .Highlighted) //添加点击事件Selector(\"btnOnClick\") 对应函数 func btnOnClick() //mButton.addTarget(self, action: Selector(\"btnOnClick\"), forControlEvents: .TouchUpInside) //添加点击事件Selector(\"btnOnClick:\") 对应函数 func btnOnClick(button:UIButton) mButton.addTarget(self, action: Selector(\"btnOnClick:\"), forControlEvents: .TouchUpInside) self.view.addSubview(mButton) } //函数定义 func 开头 func btnOnClick(){ print(\"不带参数UIButton点击事件响应 1+1=\"+\"\\(sum(1, two: 1))\") mLabel.text=\"不带参数UIButton点击事件响应计算 1+1=\"+\"\\(sum(1, two: 1))\"; } //方法定义 func 开头，方法名是 btnOnClick，传的参数是一个UIButton func btnOnClick(button:UIButton){ print(\"UIButton点击事件响应 1+1=\"+\"\\(sum(1, two: 1))\") mLabel.text=\"UIButton点击事件响应计算 1+1=\"+\"\\(sum(1, two: 1))\"; } //参数传递和返回类型 传两个Int类型的参数，返回一个Int类型 //返回类型是在（）后面使用 -> func sum(one:Int,two:Int)->(Int){ return one+two } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. } }","tags":[{"name":"UIButton","slug":"UIButton","permalink":"http://www.veidy.net/tags/UIButton/"},{"name":"Selector","slug":"Selector","permalink":"http://www.veidy.net/tags/Selector/"}]},{"title":"swift学习笔记之UILabel","date":"2016-02-10T09:11:16.000Z","path":"2016/02/10/swift_01/","text":"一、知识点：1.UI控件的初始化2.字符串的拼接3.变量和常量的定义 二、效果图： 三、代码: class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. //常量定义用let 变量定义用var let mLabel:UILabel=UILabel(); //设置显示文字 字符串和字符串可以直接用+ 拼接，字符串和int 其它类型可以用 \\() 如下，把2016放在小括号里面即可 mLabel.text=\"veidy\"+\"开始了\\(2016)年的第一次swift 开发\" //设置label背景颜色 mLabel.backgroundColor=UIColor.redColor() //设置文字颜色 mLabel.textColor=UIColor.whiteColor() //设置文字剧中对齐 mLabel.textAlignment=NSTextAlignment.Center //定义坐标位置 label大小 mLabel.frame=CGRect(x: 0, y: 20, width: self.view.frame.size.width, height: 50) //添加到view 显示，没有这一句，UI上不会显示 self.view.addSubview(mLabel) }","tags":[{"name":"UILabel","slug":"UILabel","permalink":"http://www.veidy.net/tags/UILabel/"}]},{"title":"Android Studio 使用心得","date":"2016-01-21T02:19:41.000Z","path":"2016/01/21/android-studio/","text":"&nbsp; &nbsp;版权声明：本文出自veidy的博客，转载必须注明出处&nbsp;&nbsp; &nbsp;转载请注明出处：http://www.veidy.net/&nbsp; &nbsp;之前在osc 上有整理一系列关于android studio 使用的文章Android studio 使用心得(一)—android studio快速掌握快捷键Android studio使用心得(二)— 打包签名apk发布Android studio 使用心得(三)—从Eclipse迁移到Android&nbsp;Android studio 使用心得(四)—android studio 多渠道打包Android studio 使用心得(四)—android studio 多渠道打包(二)Android studio 使用心得(五)—代码混淆和破解apkAndroid studio 使用心得(六)—android studio 如何加载.so文件Android studio 使用心得(七)—如何导入library工程包Android studio 使用心得(八)—-测试程序单元测试Android studio使用心得(九)——如何设置项目编码Android studio 使用心得(十)—android studio 多渠道打包(三)","tags":[{"name":"android","slug":"android","permalink":"http://www.veidy.net/tags/android/"},{"name":"studio混淆","slug":"studio混淆","permalink":"http://www.veidy.net/tags/studio混淆/"},{"name":"多渠道打包","slug":"多渠道打包","permalink":"http://www.veidy.net/tags/多渠道打包/"}]},{"title":"(转)如何选择compileSdkVersion,minSdkVersion和targetSdkVersion","date":"2016-01-19T01:59:49.000Z","path":"2016/01/19/如何选择compileSdkVersion-minSdkVersion和targetSdkVersion/","text":"compileSdkVersion minSdkVersion targetSdkVersion 1.翻译原文:如何选择 compileSdkVersion, minSdkVersion 和 targetSdkVersion 2.英文原文：Picking your compileSdkVersion, minSdkVersion, and targetSdkVersion 3.Android targetSdkVersion 原理","tags":[{"name":"compileSdkVersion","slug":"compileSdkVersion","permalink":"http://www.veidy.net/tags/compileSdkVersion/"},{"name":"minSdkVersion","slug":"minSdkVersion","permalink":"http://www.veidy.net/tags/minSdkVersion/"},{"name":"targetSdkVersion","slug":"targetSdkVersion","permalink":"http://www.veidy.net/tags/targetSdkVersion/"}]},{"title":"2016 计划...","date":"2015-12-25T07:18:16.000Z","path":"2015/12/25/2016计划/","text":"2015还没来得总结，忙里偷闲想把2016博客上的内容规划一下.2014的时候有给2015规划过，然后。。。已经找不到那份规划文档… 2016 要整理的几个干货。。。&nbsp; &nbsp; &nbsp;1.图片加载框架 &nbsp;Android-Universal-Image-Loader&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;2.图片加载框架 &nbsp;fresco&nbsp; &nbsp; &nbsp;3.orm 框架 &nbsp;GreenDao&nbsp; &nbsp; &nbsp;4.网络请求框架&nbsp;android-async-http&nbsp; &nbsp; &nbsp;5.网络请求框架&nbsp;okhttp&nbsp; &nbsp; &nbsp; 6.VRefreshView &nbsp; &nbsp; 基于google官方SpipeRefershLayout自定义的&nbsp;下拉刷新，上拉加载更多view.&nbsp; &nbsp; &nbsp; 7.VCycleViewPager 自定义ViewPager,可以用于引导页，轮播广告自动循环播放&nbsp; &nbsp; &nbsp; 8.VRichTextEditText 自定义EditText ，可以图文混排显示和编辑&nbsp; &nbsp; &nbsp; 9.VScrollViewContainer &nbsp;自定义View，效果就是现在很多商城APP图文详情那种，上拉查看图文详情&nbsp; &nbsp; &nbsp; 10.&nbsp;VAsyncImageUpload &nbsp;通过使用线程池&nbsp;异步多张图片上传&nbsp; &nbsp; &nbsp; …待续","tags":[]}]