[{"title":"港股打新神器","date":"2020-12-13T12:58:16.000Z","path":"2020/12/13/港股打新神器/","text":"","tags":[]},{"title":"开个早会损失两千","date":"2020-12-11T14:04:08.000Z","path":"2020/12/11/开个早会损失两千/","text":"","tags":[]},{"title":"内地开户中信国际银行","date":"2020-12-06T08:19:01.000Z","path":"2020/12/06/内地开户中信国际银行/","text":"","tags":[]},{"title":"macpro数字键盘失效","date":"2020-06-22T04:59:56.000Z","path":"2020/06/22/macpro数字键盘失效/","text":"第四次了，苹果电","tags":[{"name":"mac","slug":"mac","permalink":"http://www.veidy.net/tags/mac/"}]},{"title":"flutter 集成到现有的项目","date":"2019-06-09T11:36:55.000Z","path":"2019/06/09/flutter-集成到现有项目/","text":"直接采用官方给出的方案 Android 集成一.创建一个Flutter module假如:已经有一个android项目，veidy/project/flutterExistingApp 123$ cd veidy&#x2F;project&#x2F;$ flutter create -t module my_flutter 二.设置Android 项目配置1.app/build.gradle 配置 1234compileOptions &#123;sourceCompatibility 1.8targetCompatibility 1.8&#125; 2.android项目的 settings.gradle 配置 1234&#x2F;&#x2F;flutterExistingApp&#x2F;settings.gradleinclude &#39;:app&#39;setBinding(new Binding([gradle: this]))evaluate(new File(settingsDir.parentFile,&#39;my_flutter&#x2F;.android&#x2F;include_flutter.groovy&#39;)) 3.app module引入Flutter module 12&#x2F;&#x2F;flutterExistingApp&#x2F;settings.gradleimplementation project(&#39;:flutter&#39;) 4.android项目里面使用Flutter 123456789101112131415161718192021222324&#x2F;&#x2F;新建一个Activitypublic class FlutterIndexActivity extends AppCompatActivity &#123;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123;super.onCreate(savedInstanceState);setContentView(R.layout.activity_flutter_index);View flutterView &#x3D; Flutter.createView(this, getLifecycle(), &quot;route_saas_home&quot;);FrameLayout.LayoutParams layout &#x3D; new FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);addContentView(flutterView, layout);&#x2F;&#x2F; new MethodChannel((BinaryMessenger) flutterView,&quot;app.channel.shared.data&quot;).setMethodCallHandler((methodCall, result) -&gt; &#123;&#x2F;&#x2F;&#x2F;&#x2F; Log.d(&quot;FlutterIndexActivity&quot;,methodCall.method);&#x2F;&#x2F; result.success(&quot;android 原生 返回给 flutter 数据了&quot;);&#x2F;&#x2F; Toast.makeText(this,&quot;toast 显示&quot;,Toast.LENGTH_LONG).show();&#x2F;&#x2F;&#x2F;&#x2F; &#125;);&#125;&#125; 这里的”route_saas_home”对应了在Flutter模块里面lib/main.dart 配置 123456789101112131415161718192021222324import &#39;dart:ui&#39;;import &#39;package:flutter&#x2F;material.dart&#39;;void main()&#123;runApp(new MaterialApp(title: &#39;首页&#39;,debugShowCheckedModeBanner: false,home: _widgetForRoute(window.defaultRouteName),));&#125;Widget _widgetForRoute(String route) &#123;switch (route) &#123;case &#39;route_saas_home&#39;:return SaasHome();case &#39;route_saas_subject&#39;:return SubjectActivity();default:return Center(child: Text(&#39;Unknown route: $route&#39;, textDirection: TextDirection.ltr),);&#125;&#125; iOS 集成一.创建一个Flutter module1234$ cd veidy&#x2F;project&#x2F;flutterExistingiOS&#x2F;&#x2F;&#x2F;如果androi项目创建过了就不用再创建了$ flutter create -t module my_flutter 二、iOS项目配置1.如果之前没有集成 cocoapods的先初始化pod 12345$ cd veidy&#x2F;project&#x2F;flutterExistingiOS$ pod init$ pod install 2.在pod文件里面添加如下代码，再执行 12flutter_application_path &#x3D; &#39;..&#x2F;my_flutter&#x2F;&#39;eval(File.read(File.join(flutter_application_path, &#39;.ios&#39;, &#39;Flutter&#39;, &#39;podhelper.rb&#39;)), binding) 再次执行命令: 1$ pod install 最终整个pods文件配置如下: 12345678910111213141516171819202122# Uncomment the next line to define a global platform for your project# platform :ios, &#39;9.0&#39;target &#39;flutterExistingiOS&#39; do# Comment the next line if you&#39;re not using Swift and don&#39;t want to use dynamic frameworksuse_frameworks!# Pods for flutterExistingiOStarget &#39;flutterExistingiOSTests&#39; doinherit! :search_paths# Pods for testingendtarget &#39;flutterExistingiOSUITests&#39; doinherit! :search_paths# Pods for testingendflutter_application_path &#x3D; &#39;..&#x2F;my_flutter&#x2F;&#39;eval(File.read(File.join(flutter_application_path, &#39;.ios&#39;, &#39;Flutter&#39;, &#39;podhelper.rb&#39;)), binding)end 3.禁用 Bitcode Build Settings-&gt;Build Options-&gt;Enable Bitcode 选择 NO 4.Add a build phase for building the Dart code Build Phases-&gt;选择’+’ -&gt;New Run Script Phase -&gt; Run Script直接粘贴如下代码: 12&quot;$FLUTTER_ROOT&#x2F;packages&#x2F;flutter_tools&#x2F;bin&#x2F;xcode_backend.sh&quot; build&quot;$FLUTTER_ROOT&#x2F;packages&#x2F;flutter_tools&#x2F;bin&#x2F;xcode_backend.sh&quot; embed 5.在swift代码里面使用flutter a.AppDelegate配置 1234567891011121314import Flutterimport FlutterPluginRegistrant &#x2F;&#x2F; Only if you have Flutter Plugins.@UIApplicationMainclass AppDelegate: FlutterAppDelegate &#123;var flutterEngine : FlutterEngine?;&#x2F;&#x2F; Only if you have Flutter plugins.override func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool &#123;self.flutterEngine &#x3D; FlutterEngine(name: &quot;io.flutter&quot;, project: nil);self.flutterEngine?.run(withEntrypoint: nil);GeneratedPluginRegistrant.register(with: self.flutterEngine);return super.application(application, didFinishLaunchingWithOptions: launchOptions);&#125;&#125; 如果之前项目已经有继承别的的AppDelegate，可以实现FlutterAppLifeCycleProvider来处理 Make your app delegate implement the FlutterAppLifeCycleProvider b.原生 页面跳转到flutter配置 123456789101112131415161718192021222324252627import UIKitimport Flutterclass ViewController: UIViewController &#123;override func viewDidLoad() &#123;super.viewDidLoad()let button &#x3D; UIButton(type:UIButton.ButtonType.custom)button.addTarget(self, action: #selector(handleButtonAction), for: .touchUpInside)button.setTitle(&quot;点击我跳转到Flutter界面&quot;, for: UIControl.State.normal)button.frame &#x3D; CGRect(x: 80.0, y: 210.0, width: 160.0, height: 40.0)button.backgroundColor &#x3D; UIColor.blueself.view.addSubview(button)&#125;@objc func handleButtonAction() &#123;let flutterEngine &#x3D; (UIApplication.shared.delegate as? AppDelegate)?.flutterEngine;let flutterViewController &#x3D; FlutterViewController(engine: flutterEngine, nibName: nil, bundle: nil)!;&#x2F;&#x2F;实际上这里面设置路径，flutter无法读取flutterViewController.setInitialRoute(&quot;route1&quot;);self.present(flutterViewController, animated: false, completion: nil)&#125;&#125;","tags":[{"name":"flutter","slug":"flutter","permalink":"http://www.veidy.net/tags/flutter/"}]},{"title":"weex调用自定义原生组件","date":"2019-04-12T02:37:42.000Z","path":"2019/04/12/weex自定义原生组件/","text":"一、android 提供组件 WeexCircleImageView 123456789101112131415161718192021222324&#x2F;*** 扩展给Weex 调用的显示圆形图片 组件* @author veidy*&#x2F;public class WeexCircleImageView extends WXComponent&lt;CircleImageView&gt; &#123;public WeexCircleImageView(WXSDKInstance instance, WXVContainer parent, BasicComponentData basicComponentData) &#123;super(instance, parent, basicComponentData);&#125;public WeexCircleImageView(WXSDKInstance instance, WXVContainer parent, int type, BasicComponentData basicComponentData) &#123;super(instance, parent, type, basicComponentData);&#125;@Overrideprotected CircleImageView initComponentHostView(@NonNull Context context) &#123;return new CircleImageView(context);&#125;@WXComponentProp(name &#x3D; &quot;src&quot;)public void setImage(String url)&#123;IAskImageLoader.displayImage(url,getHostView());&#125;&#125; 二、native 注册组件 1WXSDKEngine.registerComponent(&quot;CircleImageView&quot;, WeexCircleImageView.class, false); 三、 weex JS 引用组件 1&lt;CircleImageView class&#x3D;&quot;image&quot; src&#x3D;&quot;http:&#x2F;&#x2F;ww3.sinaimg.cn&#x2F;small&#x2F;509927e5gw1eyixohfyzxj20hs0htq55.jpg&quot;&gt;&lt;&#x2F;CircleImageView&gt;","tags":[{"name":"weex","slug":"weex","permalink":"http://www.veidy.net/tags/weex/"}]},{"title":"CoordinatorLayout中的嵌套滑动和Behavior","date":"2019-03-28T06:50:27.000Z","path":"2019/03/28/CoordinatorLayout中的嵌套滑动和Behavior/","text":"CoordinatorLayout和AppBarLayout滑动弹跳（回弹）问题解决: 核心是通过反射来解决 记录一次踩坑操作 com.android.support:appcompat-v7:27.0.0 1234Object scroller &#x3D; getSuperSuperField(this, &quot;mScroller&quot;);field &#x3D; paramClass.getClass().getSuperclass().getSuperclass().getDeclaredField(paramString); com.android.support:appcompat-v7:28.0.0 1234Object scroller &#x3D; getSuperSuperField(this, &quot;scroller&quot;);field &#x3D; paramClass.getClass().getSuperclass().getSuperclass().getSuperclass().getDeclaredField(paramString); 完整源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import android.content.Context;import android.support.design.widget.AppBarLayout;import android.support.design.widget.CoordinatorLayout;import android.support.v4.view.ViewCompat;import android.util.AttributeSet;import android.view.MotionEvent;import android.view.View;import android.widget.OverScroller;import java.lang.reflect.Field;import static android.view.KeyEvent.ACTION_DOWN;&#x2F;*** 解决快速滑动抖动* &gt;&#x3D;v28: scroller* &lt;28 mScroller*&#x2F;public class FixAppBarLayoutBehavior extends AppBarLayout.Behavior &#123;private static final String TAG &#x3D; &quot;AppBarLayoutBehavior&quot;;public FixAppBarLayoutBehavior() &#123;super();&#125;public FixAppBarLayoutBehavior(Context context, AttributeSet attrs) &#123;super(context, attrs);&#125;@Overridepublic boolean onInterceptTouchEvent(CoordinatorLayout parent, AppBarLayout child, MotionEvent ev) &#123;if (ev.getAction() &#x3D;&#x3D; ACTION_DOWN) &#123;&#x2F;&#x2F; Object scroller &#x3D; getSuperSuperField(this, &quot;mScroller&quot;);Object scroller &#x3D; getSuperSuperField(this, &quot;scroller&quot;);if (scroller !&#x3D; null &amp;&amp; scroller instanceof OverScroller) &#123;OverScroller overScroller &#x3D; (OverScroller) scroller;overScroller.abortAnimation();&#125;&#125;return super.onInterceptTouchEvent(parent, child, ev);&#125;private Object getSuperSuperField(Object paramClass, String paramString) &#123;Field field &#x3D; null;Object object &#x3D; null;try &#123;&#x2F;&#x2F; field &#x3D; paramClass.getClass().getSuperclass().getSuperclass().getDeclaredField(paramString);field &#x3D; paramClass.getClass().getSuperclass().getSuperclass().getSuperclass().getDeclaredField(paramString);field.setAccessible(true);object &#x3D; field.get(paramClass);&#125; catch (Exception e) &#123;e.printStackTrace();&#125;return object;&#125;@Overridepublic void onNestedScroll(CoordinatorLayout coordinatorLayout, AppBarLayout child, View target,int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int type) &#123;super.onNestedScroll(coordinatorLayout, child, target, dxConsumed, dyConsumed,dxUnconsumed, dyUnconsumed, type);stopNestedScrollIfNeeded(dyUnconsumed, child, target, type);&#125;@Overridepublic void onNestedPreScroll(CoordinatorLayout coordinatorLayout, AppBarLayout child,View target, int dx, int dy, int[] consumed, int type) &#123;super.onNestedPreScroll(coordinatorLayout, child, target, dx, dy, consumed, type);stopNestedScrollIfNeeded(dy, child, target, type);&#125;private void stopNestedScrollIfNeeded(int dy, AppBarLayout child, View target, int type) &#123;if (type &#x3D;&#x3D; ViewCompat.TYPE_NON_TOUCH) &#123;final int currOffset &#x3D; getTopAndBottomOffset();if ((dy &lt; 0 &amp;&amp; currOffset &#x3D;&#x3D; 0)|| (dy &gt; 0 &amp;&amp; currOffset &#x3D;&#x3D; -child.getTotalScrollRange())) &#123;ViewCompat.stopNestedScroll(target, ViewCompat.TYPE_NON_TOUCH);&#125;&#125;&#125;&#125;","tags":[{"name":"AppBarLayout","slug":"AppBarLayout","permalink":"http://www.veidy.net/tags/AppBarLayout/"}]},{"title":"小程序插件使用-抽奖助手插件","date":"2018-07-26T06:16:32.000Z","path":"2018/07/26/小程序插件使用-抽奖助手插件/","text":"在使用抽奖助手插件前都得先去小程序开放平台添加插件到自己的小程序 设置 — 第三方服务 — 插件管理 —添加插件 — 抽奖助手 抽奖助手插件的AppID: wx01bb1ef166cd3f4e 抽奖助手插件的版本号：0.1.0 具体怎样使用抽奖助手插件呢？ 接入步骤如下： 1.在app.json文件加入插件引入配置 123456&quot;plugins&quot;: &#123; &quot;lottery&quot;: &#123; &quot;version&quot;: &quot;0.1.0&quot;, &quot;provider&quot;: &quot;wx01bb1ef166cd3f4e&quot; &#125;&#125; 2.新建一个Page： lottery；会自动生成四个文件 lottery.js,lottery.json,lottery.wxml,lottery.wxss 3.我们在lottery.json文件里面加入如下配置： 123&quot;usingComponents&quot;: &#123; &quot;lotterycard&quot;: &quot;plugin:&#x2F;&#x2F;lottery&#x2F;card&quot; &#125; 4.在lottery.wxml 中引入组件，代码如下: 123&lt;lotterycard lottery&#x3D;&#39;7EQUKGM0XRe&#39; redirect&#x3D;&#39;page&#39;&gt; &lt;&#x2F;lotterycard&gt; 注意： 1.lottery 这个值是动态配置的,需要先在“抽奖助手”小程序创建好抽奖后获得 2.redirect 点击奖品图片跳转方式。none: 不跳转；page: 跳转到插件抽奖详情页面 (基础库版本 &gt;= 2.1.0)；mina：跳转到抽奖助手小程序抽奖详情页（这个属于的设置前提是需要先绑定小程序 抽奖助手） 获取lottery 操作视频： 5.运行~ error示例:thirdScriptError sdk uncaught third Error Page is not a function TypeError: Page is not a function 12345thirdScriptError sdk uncaught third Error Page is not a function TypeError: Page is not a function at http:&#x2F;&#x2F;127.0.0.1:31034&#x2F;appservice&#x2F;__onlineplugin__&#x2F;wx01bb1ef166cd3f4e&#x2F;0.1.0&#x2F;appservice.js:1697:574 解决：基础库版本太低了，如官方文档设置&gt;=2.1.0 基础库版本:目前插件支持的基础库版本为 &gt;= 2.1.0, 使用前，请在公众平台小程序后台”设置-基本设置-基础库最低版本设置”，将最低版本要求设置为 2.1.0 更多使用文档可以参考抽奖助手插件官方文档： https://mp.weixin.qq.com/wxopen/plugindevdoc?appid=wx01bb1ef166cd3f4e","tags":[{"name":"小程序插件","slug":"小程序插件","permalink":"http://www.veidy.net/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8F%92%E4%BB%B6/"}]},{"title":"小程序插件使用-腾讯视频插件","date":"2018-07-25T08:59:47.000Z","path":"2018/07/25/小程序插件使用-腾讯视频插件/","text":"在使用插件前都得先去小程序开放平台添加插件到自己的小程序 设置 — 第三方服务 — 插件管理 —添加插件 — 腾讯视频 腾讯视频插件的AppID:wxa75efa648b60994b 腾讯视频插件的版本号：1.1.1 具体怎样使用腾讯视频插件呢？ 接入步骤如下： 1.在app.json文件加入插件引入配置 123456&quot;plugins&quot;: &#123; &quot;tencentvideo&quot;: &#123; &quot;version&quot;: &quot;1.1.1&quot;, &quot;provider&quot;: &quot;wxa75efa648b60994b&quot; &#125;&#125; 2.新建一个Page： video；会自动生成四个文件 video.js,video.json,video.wxml,video.wxss 3.我们在video.json文件里面加入如下配置： 123&quot;usingComponents&quot;: &#123; &quot;txv-video&quot;: &quot;plugin:&#x2F;&#x2F;tencentvideo&#x2F;video&quot;&#125; 4.在video.wxml 中引入组件，代码如下: 123&lt;txv-video playerid&#x3D;&quot;txv1&quot; vid&#x3D;&quot;h07290i9vt0&quot;&gt;&lt;&#x2F;txv-video&gt; 注意：vid 这个值是动态配置的，腾讯视频每个视频都有的 5.运行~视频就播放了 error示例: 123jsEnginScriptErrorComponent is not found in path &quot;plugin:&#x2F;&#x2F;wxa75efa648b60994b&#x2F;txv-video&quot; (using by &quot;pages&#x2F;video&#x2F;video&quot;)Error: Component is not found in path &quot;plugin:&#x2F;&#x2F;wxa75efa648b60994b&#x2F;txv-video&quot; (using by &quot;pages&#x2F;video&#x2F;video&quot;) 解决： video.json文件里面是不是写成了plugin://tencentvideo/txv-video，这样是错误的，应该是如下配置(v1.1.1) 123&quot;usingComponents&quot;: &#123; &quot;txv-video&quot;: &quot;plugin:&#x2F;&#x2F;tencentvideo&#x2F;video&quot;&#125;","tags":[{"name":"小程序插件","slug":"小程序插件","permalink":"http://www.veidy.net/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8F%92%E4%BB%B6/"}]},{"title":"如何开通民生银行香港账户","date":"2018-07-12T10:06:25.000Z","path":"2018/07/12/香港账户/","text":"2018年7月9日，小米香港上市了，除了第一天破发，后面两天都在涨~相信雷布斯没有错 小米上市了，你有买小米的股票吗？18HK一股！ 第一天小米破发，漫天的文章分析(蹭热点)，第二天就已经到了19HK，我身边的朋友已经证明了日赚1W不是梦~而我,相对来说比较淡定，还没入手。 原因有二： 1.我的香港账户还在审核中，无法通过香港账户购买 2.我是相信雷布斯的，不用急。虽然我不是米粉，曾经我还骂过小米，但是我刚想了下，我用过小米的产品有： 小米手机2S (2013年入手) 小米耳机，(2014年入手) 小米路由器，(2015年入手) 小米电子秤，(2017年入手) 小米插座，(2017年入手) 小米电饭锅，(2017年入手) 小米盒子，(2018年入手) 今年想买个小米台灯来着，家里领导没同意，暂时的~ 跑题了跑题了…明明要说香港账户的事情，说了一堆小米。 突然抛出一个问题，为什么那么多国内企业都选择在香港上市？ 如果你想买港股，一个香港银行账户还是很有必要的。 Q:为什么我要开通一个香港银行账户？ A:当然是买港股，A股你还敢买吗？ Q:大陆的银行卡不可以买吗？ A:可以，但是有很高的资金驳回风险。简单点就是：入金失败，你的人名币转换成港币，都到不了你的证券账户，更别提用证券账户去买股票了。还有一点，手续费扣得你不要不要的，我一同事一顿操作，还没买入投票就已经损失1000多这个中间的磨损是你想像不到的痛 Q:那我要开哪家银行的香港账户呢？ A:民生银行和招商银行，这两家是支持银证转账的，银证转账是玩股票很高效的一件事情，简单点就是省钱、省时间！ A:选择民生银行去开通香港账户！(我先回答了) Q: … A:因为开通香港账户是有门槛的，招商银行需要500W,民生银行5W，你选谁？ Q:怎么开！ A:… A: 内地就可以开。 Q:继续！ A: 备齐如下资料： 1.身份证 2.港澳通行证 or 护照 (优先港澳通行证，别问为什么，照做就行) 3.内地民生银行卡，并存入5W人名币！Q:继续！ A:没了，民生银行的app上预约填写资料，然后去银行办理，十分钟就给你搞定，然后只需等待审核，工作人员都会说1个月，其实看人品，你只需要记住审核期间5W不能动！ Q:就这么简单？ A:就这么简单~ Q:没有别的了？ A:没有了~ Q:那就直接讲说 准备好 身份证，港澳通行证 ，内地民生银行卡，并存入5W 就好了啊！ A: … Q:哼！ . . .去申请办理之后. . x 天之后，收到短信 Q:！！！成功~ 然而激活又折腾许久… 踩坑之后总结如下： 一.用windows系统电脑的最老的ie 浏览器登录官网（mac上的浏览器用不了的） 二.选择首次登录，然后会让你设置用户名和密码 以上是银行工作人员在开户时也会告诉你的~ 三.同名银行卡转账(继续用民生银行的app操作，而且是9:00-16:00，不要晚上弄!) 先购外汇 然后就是正常操作啦~记得不要少于300HK!不要少于300HK!不要少于300HK! 会有一个购汇理由，脑子灵活点，因私旅游！ 港币买好之后，再操作境外汇款(不截图了，就是 货币兑换 旁边)。 收款人：名字的拼音 收款账号： 香港账号，开户时工作人员就发给你了的(香港账户没有卡的，就一个虚拟账号) swift代码：MSBCHKHHXXX (民生的是这个，其实你在) 理由 ：因私旅游 在转账的时候应该会看到有两种方式，当然是 香港快汇！ 时间快，还不要手续费。 提交！ 别急，不比国内银行转账秒到。还是要等个两三分钟的~ 你就会收到香港银行到账短信~ 去登录香港分行(http://hk.cmbc.com.cn/),官网下有一个下载app的二维码，下app吧，虽然app 很难用，但是你就查询下余额不影响的~ 最后补充两句：上面的条件并不是所有城市的，大部分吧，还是以当地为标准；看完了文章之后，如果想办的，速度去办吧，因为政策是不停的变的，国家当然不希望资金留出~","tags":[]},{"title":"instagram图片批量下载","date":"2018-07-11T07:14:13.000Z","path":"2018/07/11/instagram图片批量下载/","text":"\bInstagram是一款晒照社交软件,以一种快速、美妙和有趣的方式将你随时抓拍下的图片分享给彼此！\b\bk如何下载Instagram图片呢，尤其是想一次性下载多张Instagram图片这里给大家 提供一个Instagram图片批量下载的方法~ 先说明一下：这些操作是有前提的，就是你能正常访问Instagram，访问不了的，提供一个可以让你访问的Instagram的利器。 https://portal.shadowsocks.la/aff.php?aff=11381 第一步：打开网站https://saveig.com/ 第二步：输入Insgagram用户账号，比如我这里输入杨幂的Insgagram账号：yangmi_,点击GET 第三步：选择需要的图片，并点击 Download Selected 就会一键下载啦~ 操作视频：","tags":[{"name":"instagram ins","slug":"instagram-ins","permalink":"http://www.veidy.net/tags/instagram-ins/"}]},{"title":"veidy2017.6-2018.6","date":"2018-06-15T03:10:28.000Z","path":"2018/06/15/veidy2017/","text":"时间：2018年6月14日 下班地铁1号线 脑子里面突然闪出一个想法：总结2017年6月-2018年6月 一、团队发展 app团队人员翻倍发展(4人到了8人)… 二、技术成长##2017年： 总的来说，第一件事情就是代码管理工具的迁移svn迁移到git紧接着文档完善，尤其是app接口文档 的完善与规范热更新的研究项目模块化的重构code review 尝试 android:1.项目模块化####### 引入ARouter路由框架####### 抽离 xx-android-sdk 2.项目引入kotlin语言开发3.网络框架引入 Retrofit+RxJava24.视频直播iOS:1.通过人员优化的方式提高了团队开发能力2.项目模块化3.视频直播2018年：1.code review（大工程啊）规范项目代码分支管理带着app团队最先开始项目code review，并对其他组员 进行code review 培训 2.优化项目对android 项目 进行了图片加载框架优化 …","tags":[{"name":"总结","slug":"总结","permalink":"http://www.veidy.net/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"日语口语BB","date":"2017-12-09T08:25:42.000Z","path":"2017/12/09/wx_20171209/","text":"日语口语BB是什么？ 日语口语BB是微信小程序，它是学习常用日语口语的小工具~ 里面全是生活常用的口语，比如 雅蠛蝶！？？？what? go me n na sa i！ 中文+日文+罗马音+日语发音 还有理由学不会？还学不会抽你的时候可别叫雅蠛蝶哟~ 除了分场景，还提供音乐模块和视频板块~ 推荐你好听的日语歌，一样的会有四件套(中文+日文+罗马音+日语发音) 剪辑精彩的日语视频、咳咳，不要想歪，正儿八经的日语视频，日本的电影还是很精彩的，除了爱情动作片！ 什么波多野结衣、苍井空、武藤兰这些我一个都不认识，别说波多野结衣、苍井空、武藤兰这些我不认识，我连小泽圆，松岛枫，小泽玛利亚，饭岛爱，樱树露衣，树麻里子，星野光，白石瞳，忧木瞳，相田桃，浅仓舞，小林瞳，夕树舞子，美穗由纪，小室友里，黑木香，朝冈实岭，美里真里，北原梨奈，秋元友美，川合里美，细川百合子，松阪季实子，川岛和津实，卑弥呼，小泽奈美，丰丸，叶山丽子，金泽文子，凉木桃香，铃木麻奈美，樱井利亚，香山圣，持田薰，上原空，北原多香子，樱木亚美，小泽美，藤崎秋，原纱央莉，星野亚希，雨宫琴音，朝美穗香，森下悠里等等这些我都不认识。我只知道日语口语BB！！！ 还只会“雅蠛蝶”的话你就太落伍喽送你直通车，微信扫一扫下面的小程序码,学习更多常用日语","tags":[]},{"title":"本本海报","date":"2017-12-07T08:16:13.000Z","path":"2017/12/07/wx-20171207/","text":"本本海报是什么？ “本本海报” 是一款提供有趣美图下载的工具，它是一个微信小程序。 是的，美图，无版权的高清美图，想用就用~基本能够满足日常使用 本本海报有哪些功能？ 找图片！下图片！用图片！ 找图片！下图片！用图片！ 找图片！下图片！用图片！ 重要事情说三遍！ 本本海报的定位和其它海报类型的小程序不一样，咱是图片下载为主！公众号全面开放原创功能，我想会有更多人加入进来，要想写好公众号图是少不了的，尤其是标准的900*500的封面图，所以，本本海报上线了“微封面”功能，所有图片都是标准的封面尺寸，而且，给你VR般的体验，上图： 上面说了这么多(其实也没讲几句)，上菜啦~微信扫一扫下方小程序码，直通车！！！ 另外：本本海报曾荣获第九程序 小程序小金奖。详情点击下面：撒狗粮新技能：开发个小程序送女友，甜到不行","tags":[{"name":"小程序","slug":"小程序","permalink":"http://www.veidy.net/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"三个三(iOS篇)","date":"2017-10-30T09:09:25.000Z","path":"2017/10/30/wx-03/","text":"三个社区: 1.objc中国https://www.objccn.io/为中国 Apple 开发社区带来最佳实践和先进技术(需科学上网) 2.NSHipsterhttp://nshipster.cn/关注被忽略的 Objective-C、Swift 和 Cocoa 特性。每周更新(需科学上网) 3.喵神https://onevcat.com/#blog圈内人称喵神 三个公众号:1.ios开发精髓频繁更新干货 2.iOS开发者传播iOS相关优质文章 3.iOS猿吧专注iOS开发实践技术分享，收录最新iOS技术优质文章 三个app:1.telegram号称不会被查水表的通信APP,开源。(需科学上网) 2.SendAnywhere跨平台的传输分享工具 3.ijkplayerB站开源的视频播放器","tags":[]},{"title":"三个三(android篇)","date":"2017-09-26T03:13:08.000Z","path":"2017/09/26/wx-02/","text":"三个社区:1.Android开发技术周报http://www.androidweekly.cn/每周更新。 2.谷歌开发者中文博客http://developers.googleblog.cn/如果你是android开发者，有什么理由不逛逛。 3.干货集中营http://gank.io/#jtss-tsinaf每天干货更新也就算了,每天还更新妹子！ 三个公众号:1.stormzhang帅比张没什么可说的了，屌丝逆袭高富帅，关注他，没毛病！ 2.郭霖《第二行代码》极力推荐给刚入门的android开发童鞋看这本书 3.HenCoder给高级 Android 工程师的进阶手册 三个app:1.SQLite Editorhttp://sj.qq.com/myapp/detail.htm?apkName=com.speedsoftware.sqleditor使用sqlite开发时直接可视化操作数据库 2.ExoPlayerhttps://github.com/google/ExoPlayerExoPlayer是Android的应用级媒体播放器 3.shadowsocks https://portal.shadowsocks.ch/aff.php?aff=11381给你解决android开发最大的痛点！","tags":[]},{"title":"小程序实现瀑布流","date":"2017-09-04T02:00:13.000Z","path":"2017/09/04/weixinxiao-01/","text":"​最近折腾了一款小程序，之前没有js开发经验，所以小程序的开发也是边看文档边查资料，现学现卖。 今天分享的内容也是现学现卖，如果对小程序开发感兴趣的童鞋可以先收藏，说不定用得着。先看一下效果: 是的，瀑布流！做为一个app开发的猿，在开发小程序时，想处理列表数据第一个脑子里面反射出来的就是Listview？ Tabview ？瀑布流 用RecyclerView？把小程序api文档查了个遍也没看到这样的组件。但是发现了一个词”列表渲染” wx:for 瀑布流是一个列表数据,既然列表数据解决了那就可以定实现的思路了，我来说一下我的思路：直接两个列表并排不就好了？。。。一个字，干！上wxml代码(视图层布局代码): 12345678910111213&lt;view class&#x3D;&quot;item-body&quot;&gt; &lt;view class&#x3D;&quot;body-left&quot; &gt; &lt;image wx:for&#x3D;&quot;&#123;&#123;left_array&#125;&#125;&quot; wx:key&#x3D;&quot;id&quot; class&#x3D;&#39;img_item&#39; src&#x3D;&quot; &#123;&#123;item.img_url_thumb&#125;&#125;&quot; mode&#x3D;&#39;widthFix&#39; bindtap&#x3D;&#39;tap_left_img&#39; data-poster&#x3D;&quot;&#123;&#123;item&#125;&#125;&quot;&gt;&lt;&#x2F;image&gt; &lt;&#x2F;view&gt; &lt;view class&#x3D;&quot;body-right&quot;&gt; &lt;image wx:for&#x3D;&quot;&#123;&#123;right_array&#125;&#125;&quot; wx:key&#x3D;&quot;id&quot; class&#x3D;&#39;img_item&#39; src&#x3D;&quot;&#123;&#123;item.img_url_thumb&#125;&#125;&quot; mode&#x3D;&#39;widthFix&#39; bindtap&#x3D;&#39;tap_right_img&#39; data-poster&#x3D;&quot;&#123;&#123;item&#125;&#125;&quot;&gt;&lt;&#x2F;image&gt; &lt;&#x2F;view&gt;&lt;&#x2F;view&gt; 小程序里面视图容器是View这个控件，如上代码最外层一个 item-body,里面两个 body-left 和 body-right,然后两个View里面都各有一个显示图片的组件img_item。接下来就是写CSS样式啦~ .wxss文件 里面是配置css样式。 先看item-body 12345678910111213.item-body&#123;width:100%;height:100vh;&#x2F;*弹性布局*&#x2F;display:flex;&#x2F;*横向布局*&#x2F;flex-direction:row;margin-top: 10px;background-color: white;padding-top: 5px;&#125; 最重要的就是： 1234&#x2F;*弹性布局*&#x2F;display:flex;&#x2F;*横向布局*&#x2F;flex-direction:row; 然后再看 body-left 和 body-right 12345678910&#x2F;*单列图片*&#x2F;.body-left&#123;text-align:center;flex:1;padding-left: 5px;&#x2F;* padding-top: 5px; *&#x2F;padding-bottom: 5px;&#x2F;* background-color: #000; *&#x2F;&#125; 12345678910.body-right&#123;text-align:center;flex:1;&#x2F;* background-color: #000; *&#x2F;padding-right: 5px;&#x2F;* padding-top: 5px; *&#x2F;padding-bottom: 5px;&#125; 最重要的是： 1flex:1; css文档上对flex的解释：让所有弹性盒模型对象的子元素都有相同的长度，忽略它们内部的内容是不是可以理解为android里面的权重呢？平均分，暂且就这么理解吧两个子view都设置1就等分了 最后就img_item: 12345678.img_item &#123;width:95%;vertical-align: top;margin-right: 5px;margin-left: 5px;margin-top: 5px;margin-bottom: 5px;&#125; 最后就轮到JS代码了：js代码直接在data里面定义两个array就好啦left_array:[] ，right_array[] 最后贴上本本海报的二维码，欢迎体验~","tags":[{"name":"小程序","slug":"小程序","permalink":"http://www.veidy.net/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"android 开发之aar——本地仓库发布和引用","date":"2017-07-10T07:01:35.000Z","path":"2017/07/10/aar-02/","text":"在gradle 构建的android项目里面，有了一个爽得飞起的功能就是远程依赖。如:我想引入okhttp 这个第三方开源网络请求框架，在eclipse开发时代，我们都是在github上要么把打包好的.jar文件下载下来导入，要么就是直接把源文件下载下来导入，一旦okhttp 在github有版本更新，我们又得进行同样的下载、导入工作。烦！在android studio 这么高大上的IDE出现之后，我们就只需一行代码搞定喽！ 如有版本更新，只需要更新版本号然后同步更新即可！简直不能再爽！既然这么好玩，那我们自己动手也玩一玩儿~在本地创建一个仓库,然后依赖导入项目！ 第一步:创建一个moudle “aarlibrary”第二步:maven发布到本地仓库第三步:gradle 引入 第一步就不讲了，会开发android的都会第二、三步是重点，如何在android studio 里面发布本地仓库？gradle 给我们提供了一个插件 “maven”!呵呵~ 好玩的来了，我们打开 aarlibrary 的build.gradle文件开始撸代码 如上配置之后，我们会发布右侧的gradle 面板有变化： 多了一个upload-uploadArchives!离发布就只最后一步了：双击“uploadArchives” 直到稍等片刻就发布好啦~注释里面已经定义仓库的地址是”file:///Users/veidy/Desktop/aar_/aar”找到本地文件夹发现有货啦！ 开始在app moudle引用：两步操作： 第一步：在主项目的build.gradle里面引入仓库地址配置： 第二步: 和其它包一样远程依赖： 到这整个本地仓库的发布和引用就结束啦！然后就能愉快的引入aarlibrary里面的所有资源了~记住是所有资源，真的是所有资源！所有资源！所有资源！就算是aarlibrary 里面有远程依赖其它的aar 一样没问题！假如在aarlibrary 里面有 远程依赖 1compile &#39;com.squareup.okhttp3:okhttp:3.8.1&#39; 如果像 android 开发之aar——本地文件引用 里面对aarlibrary进行打包然后导入到app moudle是找不到okhttp相关api的！但是如果以上面的形式发布到本地仓库然后依赖是没有问题的！ 如果是从上一篇文章最后抛出的问题来看这篇文章的，到这才算”正文”了! 先理一下”aarlibrary里面也有依赖另外一个moudle 如:otherLibrary” 这里有三种情况： 第一种:otherLibrary打包成一个.aar文件然后直接以文件的形式被导入到了aarlibrary moudle的libs 文件夹: 第二种:otherLibrary以项目moudle的形式被导入到aarlibrary： 第三种:otherLibrary放在本地仓库或者仓库被导入到aarlibrary: 对应第一种的解决办法:(又有三种情况) 一、如果你的app moudle的 build.gradle里面是以project的形式引用aarlibrary，可以如下解决：先在aarlibrary 的build.gradle里面添加 12345repositories &#123;flatDir &#123;dirs &#39;libs&#39; &#125;&#125; 然后在app moudle 的build.gradle 里面 12345repositories &#123;flatDir &#123;dirs &#39;libs&#39;,&#39;..&#x2F;aarlibrary&#x2F;libs&#39; &#125;&#125; 二、如果你的app moudle的build.gradle里面想以.aar文件形式引用aarlibrary，那不可能！就回到了NO.1这个问题 三、第二种情况不可能，那我们就可以用本文章的核心啊，发布本地仓库再依赖!但是,这里需要注意配置，否则，你会发现在远程依赖时失败~上篇文章已经讲了怎么引用本地.aar文件:先把otherlibrary-debug.aar文件放入aarlibrary的libs文件夹，然后在aarlibrary的build.gradle 的dependencies 里面新增下面配置: 在这，如果我们想把aarlibrary发布到本地仓库，并在app moudle里面远程依赖，需要额外添加两个配置：定义group和version！ 对应第二种的解决办法: 那就先把otherLibrary打包成.aar然后再引入到aarlibrary里面，再用上面的解决办法搞定~~哈哈哈 对应第三种的解决办法: 那就是本篇文章的核心，直接把aarlibrary整个moudle发布到本地仓库! 源码: https://git.oschina.net/veidy/aar.git ps:如果照着文章撸的还是要注意一下，如果你的gradle版本太旧可能有些方法找不到，本文是基于gradle3.3版本撸的~ demo始终是demo,真正在项目中使用时会发现更多的问题NO.2:如标题“本地仓库引用”毕竟是本地，如果你们项目团队就你一个人那可以本地，反正是你自己一个人玩，但是如果不只一个人怎么办，难倒也要让别人都在本地创建一个仓库吗显然不是！怎么办？看完下篇文章《android 开发之aar——远程仓库发布和引用》之后咱们再看这个问题 最后贴一个二维码！注意不是求打赏的二维码，是本人撸了一个微信公众号！公众号会同步分享在osc上的所有文章！当然应该会有另外有趣的东西，有兴趣的可以扫描关注~","tags":[{"name":"aar","slug":"aar","permalink":"http://www.veidy.net/tags/aar/"},{"name":"android studio","slug":"android-studio","permalink":"http://www.veidy.net/tags/android-studio/"},{"name":"maven","slug":"maven","permalink":"http://www.veidy.net/tags/maven/"}]},{"title":"android 开发之aar——本地文件引用","date":"2017-07-05T07:05:12.000Z","path":"2017/07/05/aar-01/","text":"如果你知道aar文件是个什么东西，直接切到“如何引用”吧 什么是aar文件：官方解释: 我来总结一下:aar首先它是一个后缀为.aar的文件，然后这个文件是在android项目里面使用的，它是一个android库文件，然后它比我们之前使用的.jar文件更强大！！！over~ ###如何生成：首先得创建一个库，继续官方文档走起：example: Next一直到finish一个module就创建好了~ 接下来我在新建的aarlibrary 这个module里面写一个静态方法，然后在app module里面调用 aarlibrary 的module: app的module: 压根找不到这个类，更别提方法了! 因为目前app没有对新建的 aarlibrary 进行依赖！ 官方文档继续走起！但是这都不是这篇文章的重点，这篇文章主要是想分享如何单独引用.aar文件，oh,忘记了我们还没看到.aar文件在哪，说好的如何生成呢！！！不急，先看官网怎么说： 如果希望单独共享 AAR 文件，则可以在 项目名称/模块名称/build/outputs/aar/ 中找到它，也可以通过点击 Build &gt; Make Project 的方式重新生成此文件。 尼玛，*如何生成 *这么简单 上面绕了一大堆废话! ###如何引用： 第一步:之前怎么导入的.jar文件，现在就怎么导入.aar文件喽! 第二步:在app的build.gradle里面加入下面配置 12345repositories &#123;flatDir &#123;dirs &#39;libs&#39; &#x2F;&#x2F;this way we can find the .aar file in libs folder&#125;&#125; 第三步:在app的build.gradle的dependencies里面加下面配置 1compile(name: &#39;aarlibrary-debug&#39;, ext: &#39;aar&#39;) 三步完成！接下来在app项目里面就可以正常使用aarlibrary里面的资源喽~ demo始终是demo,真正在项目中使用时会发现更多的问题NO.1:目前aarlibrary 里面可以写任意代码也可以引用任意资源文件 但是！但是！但是！如果我们的aarlibrary 里面也有依赖另外一个module 如：otherLibrary，在app项目里面却无法调用otherLibrary 里面的内容!!! 怎么办？看完下篇文章《android 开发之aar——本地仓库引用》之后咱们再看这个问题~","tags":[{"name":"aar","slug":"aar","permalink":"http://www.veidy.net/tags/aar/"}]},{"title":"App开启深度链接","date":"2017-06-12T06:58:19.000Z","path":"2017/06/12/deepLinks/","text":"理解 深度链接其实就是一个可以直接打开app或者进入到app某一个落地页的url，直接在浏览器里面打开app oh!不就是之前百度关键词”android 浏览器启动app”吗！！！ 功能实现废话不多说直接上代码！！！android端主要是在Manifest.xml里面配置： &lt;activity android:name=&quot;.BrowserLunchActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt; &lt;data android:host=&quot;blog&quot; android:scheme=&quot;veidy&quot;&gt; &lt;/data&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 在项目里面新建一个BrowserLunchActivity，并在注册的时候配置如上属性。 web端的url就可以直接这样写啦: &lt;a href=&quot;veidy://blog&quot;&gt;点击打开app&lt;/a&gt;OK！深度链接定制成功。实现是ok了，为什么是这么配置呐？首先看看 &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt;直接看看官网的解释:照着撸吧~然后最重要的是下面data的定义： &lt;data android:host=&quot;blog&quot; android:scheme=&quot;veidy&quot;&gt; &lt;/data&gt;schemeurl之所以能定位到我们的app就是在data里面设置的scheme 如果只设置scheme=”veidy”,在url的href里面写成href=”veidy://“ 一样可能打开我们app host是域名，其实就是一个适当的描述,我们可以自定义,如上我定义一个字符串”blog”,这时在url的href里面写成href=”veidy://blog”,也可以用包名定义如”com.veidy.blog.deeplinks”，那在url的href里面写成href=”veidy://com.veidy.blog.deeplinks” 指定到单独的落地页上面已经实现的深度链接的功能，在url里面打开我们的app，接下来需求实现的是不同的url，跳转到app不通的页面(Activity)如果我要到SecondActivity，就如下配置: &lt;data android:host=&quot;test&quot; android:path=&quot;/appsecond&quot; android:scheme=&quot;veidy&quot;&gt; &lt;/data&gt; 如果我要到ThirdActivity,就如下配置: &lt;data android:host=&quot;test&quot; android:path=&quot;/appthird&quot; android:scheme=&quot;veidy&quot;&gt; &lt;/data&gt; 发现我们用来区分的就是通过path！！！！ps: pathPrefix、pathPattern 一样能实现 传值如果我在跳转到app某个落地页的时候还需要传值呢？很简单了，直接拼在url后面喽。。。&lt;a href=&quot;veidy://test/appthird?key=1&amp;name=veidy&amp;sex=男&quot;&gt;进入到app指定页面ThirdActivity并传递数据 veidy://test/appthird&lt;/a&gt; 然后我们在指定的落地页取值就好啦~直拉上debug时的一个图，很清楚","tags":[{"name":"deep-links","slug":"deep-links","permalink":"http://www.veidy.net/tags/deep-links/"},{"name":"web","slug":"web","permalink":"http://www.veidy.net/tags/web/"}]},{"title":"混淆代码恢复","date":"2017-03-09T03:36:02.000Z","path":"2017/03/09/retrace/","text":"proguard 相信已经不再陌生，但是混淆代码恢复估计玩得少。 混淆配置的时候会有这么一段，重要的文件就是 mapping.txt。注释写得很清楚，代码混淆前后的映射。 可能大家都有用过友盟sdk,里面有一个功能就是分析错误，针对每一个版本都会让我们上传一个mapping.txt文件，这样 收集到的错误就不会是混淆之后的代码a.b.c，而是我们真正的包名了~ 怎么做到的呢？一顿资料查找， ReTrace!在我们SDK目录里面就有这个工具。 路径: sdk/tools/proguard/bin/proguardgui.sh 运行后就会打开GUI工具了。 选择左边最下面的ReTrace-&gt;选择apk混淆时生成的mapping.txt文件-&gt;在”Obfuscated stack trace” 里面贴出报错的代码-&gt;点击右下角的ReTrace! 在&quot;De-obfuscated stack trace&quot; 里面就会恢复出真正的源码 代码混淆还不熟悉的童鞋可以阅读下这篇文章Android studio 使用心得(五)—代码混淆和破解apk","tags":[]},{"title":"React Native","date":"2016-04-15T10:04:24.000Z","path":"2016/04/15/rn-001/","text":"","tags":[{"name":"React Native","slug":"React-Native","permalink":"http://www.veidy.net/tags/React-Native/"}]},{"title":"swift学习笔记之网络请求NSURLSession","date":"2016-04-12T07:01:21.000Z","path":"2016/04/12/swift-009/","text":"知识点：1.UILabel多行显示2.NSURLSession get post请求3.异步线程与主线程的切换 效果图： 理解：先说说NSURLSession NSURLSession是iOS7中新的网络接口 没什么可说的了。。。 再提提UILabel的多行显示，UILabel默认只显示两行，所以要想多行显示需要设置 //设置无限换行 mLabelGet?.numberOfLines=0 光设置这个还不够，还需要动态计算Label的高度 mLabelGet?.text=strContent; //根据Label上的内容计算size let newSize:CGSize=(mLabelGet?.sizeThatFits((mLabelGet?.frame.size)!))! //重新设置Label的frame mLabelGet?.frame=CGRect(x: 10, y: 25,width: newSize.width,height: newSize.height) 最后说说子线程通知UI线程 android里面子线程不能直接操作UI线程的东西，ios一样，android里面子线程通知主线程是通过handler来完成的，在ios里面，也是有api能做的 public func dispatch_async(queue: dispatch_queue_t, _ block: dispatch_block_t) 直接看代码吧。。。代码里面是通过URLSession 进行get,post请求 代码块： // // NSURLSessionController.swift // VeidySwiftDemo // // Created by veidy on 16/3/31. // Copyright © 2016年 veidy. All rights reserved. // import Foundation import UIKit import Alamofire class NSURLSessionController: UIViewController { var mLabelGet:UILabel? var mButtonGet:UIButton? var mButtonPost:UIButton? var strContent:String? var mLabelWidth:CGFloat? var mButton_Y:CGFloat=170 override func viewDidLoad() { super.viewDidLoad() self.view.backgroundColor=UIColor.whiteColor() mLabelWidth=CGFloat(self.view.frame.size.width-20) mLabelGet=UILabel(frame:CGRect(x: 10, y: 10, width: mLabelWidth!, height: 100)) mLabelGet?.textColor=UIColor.redColor() mLabelGet?.backgroundColor=UIColor.blueColor() mLabelGet?.font=UIFont.systemFontOfSize(14) //设置无限换行 mLabelGet?.numberOfLines=0 strContent=\"开始xxxggxxxggdgdsgdsgsxxxggdgdsgdsgsxxxggdgdsgdsgsxxxggdgdsgdsgsxxxggdgdsgdsgsxxxggdgdsgdsgsxxxggdgdsgdsgsdgdsgdsgs挑选换行xxxggxxxggdgdsgdsgsxxxggdgdsgdsgsxxxggdgdsgdsgsxxxggdgdsgdsgsxxxggdgdsgdsgsxxxggdgdsgdsgsxxxggdgdsgdsgsdgdsgdsgsxxxggxxxggdgdsgdsgsxxxggdgdsgdsgsxxxggdgdsgdsgsxxxggdgdsgdsgsxxxggdgdsgdsgsxxxggdgdsgdsgsxxxggdgdsgdsgsdgdsgdsgs结束\" mLabelGet?.text=strContent; //根据Label上的内容计算size let newSize:CGSize=(mLabelGet?.sizeThatFits((mLabelGet?.frame.size)!))! //重新设置Label的frame mLabelGet?.frame=CGRect(x: 10, y: 25,width: newSize.width,height: newSize.height) mButton_Y=25+(mLabelGet?.frame.height)!+10 mButtonGet=UIButton(frame: CGRect(x:self.view.frame.width/2-50, y: mButton_Y, width: 100, height: 30)) mButtonGet?.setTitle(\"get请求\", forState: UIControlState.Normal) mButtonGet?.setTitleColor(UIColor.whiteColor(), forState:UIControlState.Normal) mButtonGet?.layer.cornerRadius=6; mButtonGet?.backgroundColor=UIColor.init(red: 71/255, green: 194/255, blue: 73/255, alpha: 1.0) mButtonPost=UIButton(frame: CGRect(x:self.view.frame.width/2-50, y: mButton_Y+40, width: 100, height: 30)) mButtonPost?.setTitle(\"post请求\", forState: UIControlState.Normal) mButtonPost?.setTitleColor(UIColor.whiteColor(), forState:UIControlState.Normal) mButtonPost?.layer.cornerRadius=6; mButtonPost?.backgroundColor=UIColor.init(red: 71/255, green: 194/255, blue: 73/255, alpha: 1.0) self.view.addSubview(mLabelGet!) self.view.addSubview(mButtonGet!) self.view.addSubview(mButtonPost!) mButtonGet?.addTarget(self, action: #selector(NSURLSessionController.sessionGet), forControlEvents: UIControlEvents.TouchUpInside) mButtonPost?.addTarget(self, action: #selector(NSURLSessionController.sessionPOST), forControlEvents: UIControlEvents.TouchUpInside) } //get请求 func sessionGet() { let urlString:String = \"http://www.weather.com.cn/data/sk/101010100.html\" let url:NSURL=NSURL(string: urlString)! //创建请求 let request:NSURLRequest=NSURLRequest(URL: url) //获取SESSION let session=NSURLSession.sharedSession() //异步任务 let dataTask=session.dataTaskWithRequest(request) { (data, response, error) in if error != nil{ print(error?.code) print(error?.description) }else{ let str=NSString(data: data!, encoding: NSUTF8StringEncoding) as! String print(\"服务器返回数据:\"+str) print(NSThread.currentThread()) //异步切到主线程 dispatch_async(dispatch_get_main_queue(), { print(NSThread.currentThread()) self.mLabelGet?.text=str //重新计算label高度 let newSize:CGSize=(self.mLabelGet?.sizeThatFits((self.mLabelGet?.frame.size)!))! self.mLabelGet?.frame=CGRect(x: 10, y: 25,width: newSize.width,height: newSize.height) self.mButton_Y=25+(self.mLabelGet?.frame.height)!+10 self.mButtonGet?.frame=CGRect(x:self.view.frame.width/2-50, y: self.mButton_Y, width: 100, height: 30) self.mButtonPost?.frame=CGRect(x:self.view.frame.width/2-50, y: self.mButton_Y+40, width: 100, height: 30) }) // print(NSThread.currentThread()) } } dataTask.resume() } //post请求 func sessionPOST() { let urlString:String = \"http://v.juhe.cn/weixin/query\" let url:NSURL=NSURL(string: urlString)! //创建请求 let request:NSMutableURLRequest=NSMutableURLRequest(URL: url) //设置请求方式 request.HTTPMethod=\"POST\" //设置请求参数 let body=\"pno=1&ps=15&key=760a19928b2dad2e80083c19d289a566\" //编码post数据 let postdata=body.dataUsingEncoding(NSASCIIStringEncoding) //HTTPBody request.HTTPBody=postdata print(\"请求url\"+(request.URL?.absoluteString)!) //获取SESSION let session=NSURLSession.sharedSession() //异步任务 let dataTask=session.dataTaskWithRequest(request) { (data, response, error) in if error != nil{ print(error?.code) print(error?.description) }else{ let str=NSString(data: data!, encoding: NSUTF8StringEncoding) as! String print(\"服务器返回数据:\"+str) } } dataTask.resume() } }","tags":[{"name":"NSURLSession","slug":"NSURLSession","permalink":"http://www.veidy.net/tags/NSURLSession/"},{"name":"UILabel","slug":"UILabel","permalink":"http://www.veidy.net/tags/UILabel/"}]},{"title":"我不是程序猿-《小幸运》","date":"2016-04-02T06:12:31.000Z","path":"2016/04/02/video_001/","text":"敲代码改BUG,加班单身狗，背程序猿要背的包包，看程序猿应该看的电影，听程序猿适合听的歌，总之做程序猿该做的事，你才能说自己是程序猿 我不是程序猿 猿在这","tags":[{"name":"视频","slug":"视频","permalink":"http://www.veidy.net/tags/%E8%A7%86%E9%A2%91/"}]},{"title":"swift学习笔记之UIImageView","date":"2016-03-31T06:52:29.000Z","path":"2016/03/31/swift-008/","text":"知识点1.UIImage2.NSURLSession3.UIImageView添加点击事件 效果图 唠叨UIImageView 要显示图片就必须得用到UIImage，和android里面的ImageView 和Bitmap类似 //加载本地资源图片 mImageView.image = UIImage.init(named: \"icon\") 会不会太简单，“icon”就是图片的名字，但是它放在哪里呢 添加图片到资源文件： 点击Assets.xcassets,然后把要放入的图片直接往右边拖进去就好了 加载本地图片太简单，再尝试下加载网络，用到系统API-&gt; NSURLSession NSURLSession是iOS7中新的网络接口 就是封装的一套网络请求，可以请求基本的接口返回数据，也可以下载文件，也可以上传文件，同步，异步皆可。。。完美，比安卓的api要不要好太多 这里先看一下怎么用这个加载图片，后面再详细了解NSURLSession吧 //创建NSURL对象 let myimgUrl=NSURL(string: \"http://f.hiphotos.baidu.com/image/pic/item/b17eca8065380cd70c5150cba444ad345982814d.jpg\") //创建请求对象 let request:NSURLRequest=NSURLRequest(URL: myimgUrl!) //获取NSURLSession let mySession=NSURLSession(configuration: NSURLSessionConfiguration.defaultSessionConfiguration()) //进行一个异步任务 let dataTask=mySession.dataTaskWithRequest(request) { (imagedata, response, error) -> Void in //UIImageView展示 mImage.image=UIImage(data: imagedata!) } //启动任务 dataTask.resume() 上面的代码有一个bug,如果使用上面的代码去加载网络图片，会发现图片要加载很久才显示，为什么呢，线程阻塞！ //进行一个异步任务 let dataTask=mySession.dataTaskWithRequest(request) { (imagedata, response, error) -> Void in //UIImageView展示 mImage.image=UIImage(data: imagedata!) } 这个方法其实是处于子线程了，和android一线，子线程不能更新UI线程的东西。。。向我们IOS开发大神求救得到一种方法，比我们android的handler不要好太多…. //当前处于子线程，需要回到主线程才能更新UI dispatch_async(dispatch_get_main_queue(), { mImage.image=UIImage(data: imagedata!) }) 如何判断当前处于子线程还是主线程： print(NSThread.currentThread()) 打印出的name为main就是主线程！ 代码块 import Foundation import UIKit class ImageSwift: UIViewController { override func viewDidLoad() { super.viewDidLoad() self.view.backgroundColor = UIColor.whiteColor() let mImageView=UIImageView() mImageView.frame=CGRectMake(0, 25, 300, 450) //加载本地资源图片 mImageView.image = UIImage.init(named: \"icon\") self.view.addSubview(mImageView) //添加交互 mImageView.userInteractionEnabled=true; let tap=UITapGestureRecognizer.init(target: self, action: #selector(ImageSwift.imgtap)) mImageView.addGestureRecognizer(tap) //加载网络图片 showNetImg(mImageView) } func imgtap(){ let mVC=UITableViewSwift() self.presentViewController(mVC, animated: false, completion: nil) } //异步加载网络图片 func showNetImg(mImage:UIImageView){ //创建NSURL对象 let myimgUrl=NSURL(string: \"http://f.hiphotos.baidu.com/image/pic/item/b17eca8065380cd70c5150cba444ad345982814d.jpg\") //创建请求对象 let request:NSURLRequest=NSURLRequest(URL: myimgUrl!) //获取NSURLSession let mySession=NSURLSession(configuration: NSURLSessionConfiguration.defaultSessionConfiguration()) //进行一个异步任务 let dataTask=mySession.dataTaskWithRequest(request) { (imagedata, response, error) -> Void in //当前处于子线程，需要回到主线程才能更新UI dispatch_async(dispatch_get_main_queue(), { mImage.image=UIImage(data: imagedata!) }) } //启动任务 dataTask.resume() } }","tags":[{"name":"NSURLSession","slug":"NSURLSession","permalink":"http://www.veidy.net/tags/NSURLSession/"},{"name":"UIImageView","slug":"UIImageView","permalink":"http://www.veidy.net/tags/UIImageView/"}]},{"title":"swift学习笔记之数据持久化(属性列表)","date":"2016-03-30T08:48:20.000Z","path":"2016/03/30/swift-007/","text":"知识点沙箱NSUserDefaultsUITextField基本使用软键盘的关闭静态类 效果图 理解这里只写写有关存储的属性列表，关于UITextField的看代码的注释吧 ios数据持久化方式有: 属性列表，对象归档，SQLite,Core Data 沙箱 沙箱目录是一种数据安全策略，ios有一套完整的数据安全体系，ios应用程序只能访问自己的目录，这个目录称为沙箱目录。 沙箱目录里面有几个特定的文件夹 |---Documents | |---Library | ---Caches | ---Preferences |---tmp 这几个文件夹需要注意的是tmp文件夹，其它文件夹里面的数据都不会自己清空，除非程序卸载掉，但是tmp文件夹里面的内容是程序每次重启都会清空的 //获取Document目录 let documentsDirectory = NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory.DocumentDirectory,NSSearchPathDomainMask.UserDomainMask, true) let paths = documentsDirectory[0] as String //获取Library目录 let paths = NSSearchPathForDirectoriesInDomains( NSSearchPathDirectory.LibraryDirectory,NSSearchPathDomainMask.UserDomainMask, true)[0] as String //获取Cache目录 程序退出不会清空 let paths=NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory.CachesDirectory, NSSearchPathDomainMask.UserDomainMask, true)[0] as String //获取tmp文件夹路径 let paths=NSTemporaryDirectory() .plist文件理解为就是一个xml文件，键值对的形式存储数据，但是对数据类型有限制了，只能是以下数据类型 NSArray;NSMutableArray;NSDictionary;NSMutableDictionary;NSData;NSMutableData;NSString;NSMutableString;NSNumber;NSDate; 创建一个plist文件，存放 NSDictionary，调用writeToFile(path, atomically: true) //新建一个plist文件 Helper.createPlistFile(\"veidyplist\") //创建一个plist文件 static func createPlistFile(name:String){ let dict = NSDictionary.init(object: \"plist\", forKey: \"name\") let path=DocumentsPath()+\"/\"+name+\".plist\" dict.writeToFile(path, atomically: true) } 打印出路径，前往文件夹就能找到这个plist文件 读取plist let dic:NSDictionary = NSDictionary.init(contentsOfFile: Helper.DocumentsPath()+\"/veidyplist.plist\")! let value = dic.valueForKey(\"name\") if (value != nil) { print(\"VALUE=\"+(value as! String)) } NSUserDefaultsNSUserDefaults也是一个plist文件,它在Library/Preferenes 下面其实我们一般使用这个来存储一些配置信息就够用了，不需要自己再创建一个plist文件 存储使用： let userDefault=NSUserDefaults.standardUserDefaults() userDefault.setObject(\"uservalue\", forKey: \"key\") //同步 userDefault.synchronize() 获取存储数据： let userDefault=NSUserDefaults.standardUserDefaults() let value = username?.objectForKey(\"key\") as! String 全文下来还没提到 属性列表 这四个字。。。其实就是指的plist文件了 静态类和java 没什么区别， static func name()，然后直接用类名调方法 代码块这里是以一个登录界面做为例子。用户进入登录界面，先帮用户查询是否有过登录记录，有则直接加载显示，没有则在用户点击登录的时候保存以便下次可以读取 先贴出一个静态帮助类Helper.swift // // Helper.swift // VeidySwiftDemo // // Created by veidy on 16/3/29. // Copyright © 2016年 veidy. All rights reserved. // import Foundation class Helper: NSObject { static func getHomePath()->String{ let homepath=NSHomeDirectory() return homepath } //Documents目录 苹果建议将程序中建立的或在程序中浏览到的文件数据保存在该目录下，iTunes备份和恢复的时候会包含此目录 static func DocumentsPath()->String{ let documentsDirectory = NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory.DocumentDirectory,NSSearchPathDomainMask.UserDomainMask, true) let paths = documentsDirectory[0] as String print(\"paths=\"+paths) return paths } //Library目录 这个目录下有2个子目录：Caches缓存 , Preferences偏好设置,不应该直接创建偏好设置文件而使用NSUserDefaults类 static func LibraryPath()->String{ let paths = NSSearchPathForDirectoriesInDomains( NSSearchPathDirectory.LibraryDirectory,NSSearchPathDomainMask.UserDomainMask, true)[0] as String return paths } //Cache目录 程序退出不会清空 static func cachePath()->String{ let paths=NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory.CachesDirectory, NSSearchPathDomainMask.UserDomainMask, true)[0] as String return paths } //tmp目录 存放临时文件，程序再次启动会清空 static func tmpPath()->String{ let paths=NSTemporaryDirectory() return paths } //创建一个文件夹 static func createFileDirectory(path:String){ let fileManager=NSFileManager.defaultManager() if !fileManager.fileExistsAtPath(path){ print(\"创建文件夹\") try! fileManager.createDirectoryAtPath(path, withIntermediateDirectories: true, attributes: nil) }else{ print(\"文件夹已经存在\") } } //创建一个plist文件 static func createPlistFile(name:String){ let dict = NSDictionary.init(object: \"plist\", forKey: \"name\") let path=DocumentsPath()+\"/\"+name+\".plist\" dict.writeToFile(path, atomically: true) } } 登录界面 // // LoginController.swift // VeidySwiftDemo // // Created by veidy on 16/3/29. // Copyright © 2016年 veidy. All rights reserved. // import Foundation import UIKit class LoginController: UIViewController,UITextFieldDelegate { var mUsername:UITextField? var mPassword:UITextField? var mLogin:UIButton? override func viewDidLoad() { super.viewDidLoad() self.view.backgroundColor=UIColor.whiteColor() initDirConfig() mUsername=UITextField.init(frame: CGRect.init(x: (self.view.frame.size.width/2)-130, y: 100, width: 260, height: 30)) mUsername?.backgroundColor=UIColor.whiteColor() //设置提示语 mUsername?.placeholder=\"手机号\" //自定义字体 // mUsername?.font=UIFont.init(name: \"STHeitiSC-Medium\", size: 14) //使用系统字体 mUsername?.font=UIFont.systemFontOfSize(14) mUsername?.textAlignment=NSTextAlignment.Center //自定义颜色 r:71 g:194 b:73 mUsername?.textColor=UIColor.init(red: 175/255, green: 175/255, blue: 175/255, alpha: 1.0) //设置边框样式 mUsername?.borderStyle=UITextBorderStyle.RoundedRect //设置弹出键盘样式 mUsername?.keyboardType=UIKeyboardType.PhonePad; mUsername?.clearButtonMode=UITextFieldViewMode.WhileEditing; mPassword=UITextField.init(frame:CGRect.init(x: (self.view.frame.size.width/2)-130, y: 140, width: 260, height: 30) ) mPassword?.backgroundColor=UIColor.whiteColor() mPassword?.placeholder=\"密码\" mPassword?.textAlignment=NSTextAlignment.Center mPassword?.textColor=UIColor.init(red: 175/255, green: 175/255, blue: 175/255, alpha: 1.0) mPassword?.borderStyle=UITextBorderStyle.RoundedRect //密码输入 mPassword?.secureTextEntry=true; //右边出现一个可清空的按钮 mPassword?.clearButtonMode=UITextFieldViewMode.WhileEditing; mPassword?.delegate=self; mLogin=UIButton.init(frame: CGRect.init(x: (self.view.frame.size.width/2)-130, y:180, width: 260, height: 30) ) mLogin?.frame=CGRect.init(x: (self.view.frame.size.width/2)-130, y:180, width: 260, height: 30) mLogin?.backgroundColor=UIColor.init(red: 71/255, green: 194/255, blue: 73/255, alpha: 1.0) mLogin?.setTitle(\"登录\", forState: UIControlState.Normal) //设置圆角 mLogin?.layer.cornerRadius=6 mLogin?.highlighted=true //设置文字大小 mLogin?.titleLabel?.font=UIFont.systemFontOfSize(14) mLogin?.addTarget(self, action: #selector(loginOnclick), forControlEvents: .TouchUpInside) self.view.addSubview(mUsername!) self.view.addSubview(mPassword!) self.view.addSubview(mLogin!) readInfo() } func textFieldDidBeginEditing(textField: UITextField) { print(\"监听 textFieldDidBeginEditing 点击输入框\") } func textFieldDidEndEditing(textField: UITextField) { print(\"监听 textFieldDidEndEditing 离开输入框\") } func loginOnclick(){ //首先关闭软键盘 self.view.endEditing(true) saveInfo() let UITableVC=UITableViewSwift() self.presentViewController(UITableVC, animated: true, completion: nil) } //放弃第一响应者 func textFieldShouldReturn(textField: UITextField) -> Bool{ print(\"textFieldShouldReturn\") textField.resignFirstResponder() return true } override func viewWillAppear(animated: Bool){ //注册通知 } override func viewWillDisappear(animated: Bool) { //解除通知 } //保存配置信息 Preference func saveInfo(){ let userDefault=NSUserDefaults.standardUserDefaults() userDefault.setObject(mUsername?.text, forKey: \"username\") userDefault.setObject(mPassword?.text, forKey: \"password\") //同步 userDefault.synchronize() } //读取配置信息 Preference func readInfo(){ let userDefault=NSUserDefaults.standardUserDefaults() let username=userDefault.objectForKey(\"username\") let password=userDefault.objectForKey(\"password\") if (username != nil){ mUsername?.text=username as? String } if (password != nil) { mPassword?.text=password as? String } } func initDirConfig(){ print(\"getHomePath() \"+Helper.getHomePath()) print(\"DocumentsPath() \"+Helper.DocumentsPath()) print(\"LibraryPath() \"+Helper.LibraryPath()) print(\"初始化目录。。。\") //新建一个plist文件 Helper.createPlistFile(\"veidyplist\") let dic:NSDictionary = NSDictionary.init(contentsOfFile: Helper.DocumentsPath()+\"/veidyplist.plist\")! let value = dic.valueForKey(\"name\") if (value != nil) { print(\"VALUE=\"+(value as! String)) } } }","tags":[{"name":"NSUserDefaults","slug":"NSUserDefaults","permalink":"http://www.veidy.net/tags/NSUserDefaults/"}]},{"title":"swift学习笔记之自定义UITableViewCell","date":"2016-03-25T08:56:23.000Z","path":"2016/03/25/swift-006/","text":"知识点：UITableView 自定义cellcell高度自定义 效果图: 唠叨: 第一次弄这个自定义cell…宝宝心里苦啊。。。。 为什么要自定义cell？因为系统的cell就一个label和一个image，在项目里面是不够的。 自定义cell首先得新建一个类，继承UITableViewCell，并重写init方法 class JokeCell: UITableViewCell { //必须重写 required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) } } 然后就是定义控件布局我要放两个Label,那就定义两个Label var mContent:UILabel? var mTime:UILabel? 然后，我们要在哪里初始化这些控件呢？1.先定义一个方法setUI()，把初始化这些东西都在setUI()里面处理 func setUI(){ if(self.mContent==nil){ self.mContent=UILabel() self.mContent!.frame=CGRect.init(x: 10, y: 0, width: 100, height: 50) self.addSubview(self.mContent!) } if(self.mTime==nil){ self.mTime=UILabel() self.mTime!.frame=CGRect.init(x: 0, y: 60, width: self.frame.size.width, height: 50) mTime!.textAlignment=NSTextAlignment.Right mTime!.textColor=UIColor.redColor() self.addSubview(mTime!) } //50+10+50 ==110 ,所以cell高度可以设置为110 } 当我们在设置控件坐标的时候就能算出这个cell的高度了。mContent Y的起点为0，高度为50，mTime的Y为60，高度为50,所以就是这个cell的高度就是 60+50=110。 在哪里设置cell的高度呢？目前我知道的有两种方法，第一种好简单，回到UIViewController //统一设置 tableView 行高 self.tableView?.rowHeight=110; 第二种也很好玩: 在UITableViewDelegate里面找到一个方法 func tableView(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -> CGFloat 重写ok 这种更适合在cell有多种布局的时候，最常用的就是聊天的界面。。。有单个的文字cell，有单个的图片cell 好了，回到前面讲的setUI()，在哪里调用这个方法呢？ 我找到一个好地方，在自定义cell里面重写另外一个方法 //可选重写，但是建议这么玩，把UI初始化放里面更方便 override init(style: UITableViewCellStyle, reuseIdentifier: String?) { super.init(style: style, reuseIdentifier: reuseIdentifier) setUI() } setData(joke:Joke)把setUI()放在这个里面，不用再管了。然后再定义一个赋值的方法setData(joke:Joke) //设置数据 func setData(joke:Joke){ mTime!.text=joke.time mContent!.text=joke.content } 那么setData(joke:Joke)方法我们在哪里调呢？？？ 这样自定义的JokeCell就搞定了不用管了，只有一个setData()被调用了。 怎么用JokeCell回到UIViewController， UITabView 初始化什么的就过了，可以看上一篇文章swift学习笔记之UITableView，但是使用自定义的时候有两个地方需要注意 第一个地方是cell注册的时候： self.tableView!.registerClass(JokeCell.self, forCellReuseIdentifier: \"swift_cell\") 要用哪个cell就注册哪个，这里一定要记得改啊，别一直用UITableViewCell.self 第二个注意的地方当然就是 func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell 这个方法里面取cell的时候 //如果是自定义cell，记得在注册的时候改成自定义cell。 let cell=tableView.dequeueReusableCellWithIdentifier(id_cell,forIndexPath: indexPath) as? JokeCell swift语法真是骚。。。 as? JokeCell 这样我们就拿到了自定义cell JokeCell. 接着就是给cell赋值了 //记得取的时候 as ? JokeCell,不要问我为什么，宝宝心里苦 cell!.setData(data) command+R 搞定收工！ 代码块：实体Joke // // Joke.swift // VeidySwiftDemo // // Created by veidy on 16/3/21. // Copyright © 2016年 veidy. All rights reserved. // import Foundation class Joke: NSObject { var content:String?; var url:String?; var time:String?; } 自定义cell JokeCell // // JokeCell.swift // VeidySwiftDemo // // Created by veidy on 16/3/25. // Copyright © 2016年 veidy. All rights reserved. // import UIKit class JokeCell: UITableViewCell { var mContent:UILabel? var mTime:UILabel? //必须重写 required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) } //可选重写，但是建议这么玩，把UI初始化放里面更方便 override init(style: UITableViewCellStyle, reuseIdentifier: String?) { super.init(style: style, reuseIdentifier: reuseIdentifier) setUI() } //初始化UI func setUI(){ if(self.mContent==nil){ self.mContent=UILabel() self.mContent!.frame=CGRect.init(x: 10, y: 0, width: 100, height: 50) self.addSubview(self.mContent!) } if(self.mTime==nil){ self.mTime=UILabel() self.mTime!.frame=CGRect.init(x: 0, y: 60, width: self.frame.size.width, height: 50) mTime!.textAlignment=NSTextAlignment.Right mTime!.textColor=UIColor.redColor() self.addSubview(mTime!) } //50+10+50 ==110 ,所以cell高度可以设置为110 } //设置数据 func setData(joke:Joke){ mTime!.text=joke.time mContent!.text=joke.content } override func setSelected(selected: Bool, animated: Bool) { super.setSelected(selected, animated: animated) } } UITableViewSwift.swift // // UITableViewSwift.swift // VeidySwiftDemo // // Created by veidy on 16/3/21. // Copyright © 2016年 veidy. All rights reserved. // import Foundation import UIKit class UITableViewSwift: UIViewController,UITableViewDelegate,UITableViewDataSource { var tableView:UITableView? //定义一个集合 var jokeList = [Joke](); override func loadView() { super.loadView() } override func viewDidLoad() { super.viewDidLoad() self.view.backgroundColor = UIColor.whiteColor() for index in 0...15{ print(index) let joke:Joke=Joke() joke.time=\"2016-03-2\\(i)\" joke.content=\"swift_ios_\\(i)\"; self.jokeList.append(joke) } self.tableView=UITableView(frame: self.view.frame, style: .Grouped) //指定代理对象 self.tableView!.delegate=self //指定代理对象 self.tableView!.dataSource=self; self.tableView!.registerClass(JokeCell.self, forCellReuseIdentifier: \"swift_cell\") self.view.addSubview(self.tableView!) //统一设置 tableView cell 高度 self.tableView?.rowHeight=110; } //UITableViewDataSource 委托回调方法 必须需要实现的方法 , 可以理解为android 里面BaseAdapter 的 getView方法 func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell{ let id_cell=\"swift_cell\" //根据位置取到joke 相当于android里面的getItem(int position) let data=self.jokeList[indexPath.row] //通过id去取cell，这样的做法和android 里面的ViewHoler类似功能 //如果是自定义cell，记得在注册的时候改成自定义cell。 let cell=tableView.dequeueReusableCellWithIdentifier(id_cell, forIndexPath: indexPath) as? JokeCell print(\"\\(indexPath.row)\"+data.content!) //记得取的时候语 as ? JokeCell,不要问我为什么，宝宝心里苦 cell!.setData(data) return cell!; } //UITableViewDataSource 必须需要实现的方法 可以理解为android 里面BaseAdapter 的 getcount方法 func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -> Int{ return self.jokeList.count; } //UITableViewDelegate 可以实现方法 cell点击事件，相当于android 里面listview的 onItemClick方法 func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath){ let joke=self.jokeList[indexPath.row] print(\"点击 ：\"+joke.content!) } //动态计算cell高度 // func tableView(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -> CGFloat{ // // return 110； // } }","tags":[{"name":"UITableViewCell","slug":"UITableViewCell","permalink":"http://www.veidy.net/tags/UITableViewCell/"}]},{"title":"520-程序员的浪漫表达方式","date":"2016-03-25T03:46:13.000Z","path":"2016/03/25/veidy-002/","text":"本文由 程序员的资料库 整理! 下面是整理自Quora社区回答的积攒最高的程序员的浪漫表达方式。为了保持原味性，有些简短的就在就保留英文原文。 Question 我刚从一个我喜欢的、却还无法得到她的心的女孩那里获得一个灵感，因此我提出了这个问题。她是我的源之泉。Sorry for the bugs. Blame her!我不知道这是否有效，但是我真的没法集中注意力写代码了，都是因为她。所以，我想听听大家喜欢的一些有关程序员浪漫编程的引用。 1.I always thought love was an abstract class until you made an instance of it. (我一直以为爱是一个抽象的类，直到你实例化了它） 2.You and svn are the only things that ill commit to 3.SELECT * FROM World WHERE “Someone” LIKE ‘%You%’ （SQL查询语句） 4.You are the {CSS} to my {/HTML} 5.while无限循环 6. 7.//Love you a lot while (i&lt;3) you++; 英文地址：Are-there-any-romantic-programming-programmer-quotes","tags":[]},{"title":"swift学习笔记之UITableView","date":"2016-03-23T01:57:59.000Z","path":"2016/03/23/swift_005/","text":"UITableView的简单使用 一、知识点:UITableView集合for循环使用 二、效果图： 三、我的理解1.UITabView和android里面的ListView相似，当然功能比ListViw强大得多，比Recyclerview也要厉害. 2.UITableViewDataSource 和 UITableViewDelegate 协议和委托代理回调，这是ios开发里面非常重要的一个东西(之前弄OC的时候ios开发的同事跟我这样说)，swift 里面的协议其实和android java里面的接口 功能类似，重要！所以有关协议和委托代理 的使用 准备单独整理成一篇文章 3.在使用UITabView的时候，controller必须要继承UITableViewDataSource当你继承UITableViewDataSource的时候xcode会提示错误，因为需要我们实现其必须要实现的方法，进入源码可以看到有两个 @available(iOS 2.0, *) public func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -> Int 这个方法可以理解为android 里面BaseAdapter 的 getcount方法,不用多说，直接返回集合的大小即可 @available(iOS 2.0, *) public func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell 这个方法可以理解为android 里面BaseAdapter 的 getView方法 tip:如何知道协议的哪些方法必须要实现：public前面并没有加上 optional 就说明是必须要实现的。(这一点还是没有java的ide做得好，必须要实现的方法没实现快捷键会立刻实现) 4.demo中我还继承了一个UITableViewDelegate类，委托代理，看源码发现也是继承NSObjectProtocol，也可以理解为是一个协议(先这么理解吧)，如果要实现列表的cell点击事件，就得继承UITableViewDelegate，然后实现其一个方法 optional public func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) 这个方法和android 里面的onItemClick 类似 public void onItemClick(AdapterView parent, View view, int position, long id) 5.? 和 ！ 很有意思的两个东西？ 当我们声明一个变量的时候，我们并不确定给其初始化的时候就可以这么干如： var tableView:UITableView? 声明一个tableView,如果var tableView:UITableView 这样声明会报错，加上？就不报错了。为什么呢？ Swift语言使用var定义变量，但和别的语言不同，Swift里不会自动给变量赋初始值，也就是说变量不会有默认值，所以要求使用变量之前必须要对其初始化。如果在使用变量之前不进行初始化就会报错 为什么加上？就不报错了，这里又得提到swift里面的一个新东西Optional ，这是个神马玩意儿，看源码发现就是一个enum！！！ public enum Optional : _Reflectable, NilLiteralConvertible { case None case Some(Wrapped) } var tableView:UITableView? 就是 var tableView: Optional这句话我们正确的解读是：声明了一个Optional类型值，它可能包含一个UITableView值，也可能什么都不包含。本来是声明一个UITabView变成了声明了一个Optional类型。一旦声明为Optional的，如果不显式的赋值就会有个默认值nil，所以就不报错啦！ ！这个东西就是非空判断 self.tableView!.delegate=self 表示我的tableView非空的 ####### 关于？和！暂时就这样理解了，以后再单独整理一篇文章深入了解 6.for循环遍历 swift 里面的for循环有两种遍历方式，一看便知道区别 第一种： for index in 0...15{ print(index) let joke:Joke=Joke() joke.content=\"swift_ios_\\(index)\"; self.jokeList.append(joke) } 打印出: 0123456789101112131415 等于集合大小为 16 第二种： 1234567for var i&#x3D;0;i&lt;15;i++ &#123; print(i) let joke:Joke&#x3D;Joke() joke.content&#x3D;&quot;swift_ios_\\(i)&quot;; self.jokeList.append(joke) &#125; 打印出： 01234567891011121314 等于集合大小为 15 区别显而易见了吧。 四、代码块Joke 是我自定义的一个实体 class Joke: NSObject { var content:String?; var url:String?; } 由于莫名的排版问题，我先把给集合的循环赋值贴出来 //初始化数据for var i=0; i&lt;15; i++ { let joke:Joke=Joke()joke.content=”swift_ios_(i)”;self.jokeList.append(joke) } // // UITableViewSwift.swift // VeidySwiftDemo // // Created by veidy on 16/3/21. // Copyright © 2016年 veidy. All rights reserved. // import Foundation import UIKit class UITableViewSwift: UIViewController,UITableViewDelegate,UITableViewDataSource { var tableView:UITableView? //定义一个集合 var jokeList = [Joke](); override func loadView() { super.loadView() } override func viewDidLoad() { super.viewDidLoad() self.view.backgroundColor = UIColor.whiteColor() for index in 0...15{ print(index) let joke:Joke=Joke() joke.content=\"swift_ios_\\(index)\"; self.jokeList.append(joke) } print(\"第一种循环遍历后 count=\\(self.jokeList.count)\") //清空数组 self.jokeList.removeAll(); print(\"清空之后,count=\\(self.jokeList.count)\") //初始化数据 //... print(\"第二种循环遍历后 count=\\(self.jokeList.count)\") self.tableView=UITableView(frame: self.view.frame, style: .Grouped) //指定代理对象 self.tableView!.delegate=self //指定代理对象 self.tableView!.dataSource=self; self.tableView!.registerClass(UITableViewCell.self, forCellReuseIdentifier: \"swift_cell\") self.view.addSubview(self.tableView!) } //UITableViewDataSource 委托回调方法 必须需要实现的方法 , 可以理解为android 里面BaseAdapter 的 getView方法 func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell{ let id_cell=\"swift_cell\" //通过id去取cell，这样的做法和android 里面的ViewHoler类似功能 //注意这里之所以能取是前面先注册过 self.tableView!.registerClass(UITableViewCell.self, forCellReuseIdentifier: \"swift_cell\") let cell=tableView.dequeueReusableCellWithIdentifier(id_cell, forIndexPath: indexPath) //根据位置取到joke 相当于android里面的getItem(int position) let data=self.jokeList[indexPath.row] //给textLabel赋值 cell.textLabel?.text=data.content return cell; } //UITableViewDataSource 必须需要实现的方法 可以理解为android 里面BaseAdapter 的 getcount方法 func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -> Int{ return self.jokeList.count; } //UITableViewDelegate 可以实现方法 cell点击事件，相当于android 里面listview的 onItemClick方法 func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath){ let joke=self.jokeList[indexPath.row] print(\"点击 ：\"+joke.content!) } } 显然，这只是简单的使用UITableView,真正项目中是不够的，下一遍文章准备记录如何使用自定义cell。","tags":[{"name":"UITableView","slug":"UITableView","permalink":"http://www.veidy.net/tags/UITableView/"}]},{"title":"程序出错后，程序员给测试人员的20条高频回复","date":"2016-03-21T07:07:04.000Z","path":"2016/03/21/veidy-01/","text":"本文由 伯乐在线 - 黄利民 翻译 编者按：程序员和软件测试员之间的关系无须多言。这些经典回复是国外程序员总结分享的，“全球通用”。 “That’s weird…” 很奇怪…… “It’s never done that before.” 以前没这样过的。 “It worked yesterday.” 昨天还好好的。 “How is that possible?” 那怎么可能？（怎么会出问题？） “It must be a hardware problem.” 这一定是硬件问题。 “What did you type in wrong to get it to crash?” 你输入什么东西后才崩溃的？ “There is something funky in your data.” 你的数据有问题。 “I haven’t touched that module in weeks!” 我好几个礼拜没动那个程序了！ “You must have the wrong version.” 你一定在用错误的版本。 “It’s just some unlucky coincidence.” 这只是凑巧。 “I can’t test everything!” 我无法测试所有东西。（我的机器环境下，无法测试所有的可能情况。） “THIS can’t be the source of THAT.” “这”不可能是问题的原因。 “It works, but it hasn’t been tested.” 程序能用，不过还没有测试。 “Somebody must have changed my code.” 一定有人改了我的代码。 “Did you check for a virus on your system?” 你的电脑扫描病毒了么？ “Even though it doesn’t work, how does it feel? 即便程序不行了，（你觉得）程序写得如何？ “You can’t use that version on your system.” 你不能在你系统上使用那个版本的程序。（程序版本和系统有冲突。） “Why do you want to do it that way?” 你怎么会想着那样操作啊？ “Where were you when the program blew up?” 程序崩溃时，你在做什么呢？（做了哪些操作？） 第1条会是什么？猜猜看吧！:) _ “It works on my machine” 在我机器上好好的！！！（潜台词：怎么在你那就出问题了呢！！！） 编者后话 虽然已经远离编程，但经常还是会用到第20、19条，当然也不会“错过”第1条。各位看过之后，不知你都用上了哪几条哦~","tags":[]},{"title":"swift学习笔记之界面之间的跳转","date":"2016-03-11T07:16:54.000Z","path":"2016/03/11/swift_004/","text":"Controller之间的跳转一、知识点： 1.api:presentViewController() , dismissViewControllerAnimated() 二、demo场景 A controller 上有一个按钮，点击按钮后跳转到B controller上，B controller上有一个标签，点击标签回退到A controller 三，代码 A controller 核心代码： //button点击响应方法，推出SecondViewController（）func btnOnClick(button:UIButton){ let VC=SecondViewController() //推出新的Controller self.presentViewController(VC, animated: false, completion: nil)} B controller 上的Label点击返回上一个controller 核心代码 func tapLabel(){ //关掉当前dismissViewController self.dismissViewControllerAnimated(false, completion: nil)} //数据传递，待续。。。","tags":[{"name":"presentViewController","slug":"presentViewController","permalink":"http://www.veidy.net/tags/presentViewController/"},{"name":"dismissViewControllerAnimated","slug":"dismissViewControllerAnimated","permalink":"http://www.veidy.net/tags/dismissViewControllerAnimated/"}]},{"title":"swift学习笔记之UILabel(二)","date":"2016-03-01T10:06:21.000Z","path":"2016/03/01/swift_003/","text":"UILabel添加点击事件一.知识点 1.UITapGestureRecognizer 二.demo场景 点击UILabel 响应自定义方法 tapLabel()， tapLabel()里面输出日志打印 三.代码class SecondViewController :UIViewController {override func viewDidLoad() { super.viewDidLoad() let mLabel:UILabel=UILabel.init(frame: CGRectMake(100,100, 100, 30)) mLabel.text=\"点我\" mLabel.textAlignment=NSTextAlignment.Center mLabel.backgroundColor=UIColor.redColor() //用户交互功能打开状态 mLabel.userInteractionEnabled=true //点击事件 let tap = UITapGestureRecognizer.init(target: self, action: Selector.init(\"tapLabel\")) //绑定tap mLabel.addGestureRecognizer(tap) self.view.addSubview(mLabel)}//定义方法，mLabel点击后调用此方法func tapLabel(){ print(\"tap the label\")}}","tags":[{"name":"UILabel","slug":"UILabel","permalink":"http://www.veidy.net/tags/UILabel/"},{"name":"UITapGestureRecognizer","slug":"UITapGestureRecognizer","permalink":"http://www.veidy.net/tags/UITapGestureRecognizer/"}]},{"title":"Swift学习笔记之UIButton(一)","date":"2016-02-12T15:12:40.000Z","path":"2016/02/12/swift_02/","text":"一、知识点：1.全局变量的定义2.UIButton添加点击事件3.函数定义 二、效果图： 三、代码： import UIKit //定义全局变量 let mLabel:UILabel=UILabel(); class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. //常量定义用let 变量定义用var //let mLabel:UILabel=UILabel(); //设置显示文字 字符串和字符串可以直接用+ 拼接，字符串和int 其它类型可以用 \\() 如下，把2016放在小括号里面即可 mLabel.text=\"veidy\"+\"开始了\\(2016)年的第一次swift 开发\" //设置label背景颜色 mLabel.backgroundColor=UIColor.redColor() //设置文字颜色 mLabel.textColor=UIColor.whiteColor() //设置文字剧中对齐 mLabel.textAlignment=NSTextAlignment.Center //定义坐标位置 label大小 mLabel.frame=CGRect(x: 0, y: 20, width: self.view.frame.size.width, height: 50) //添加到view 显示，没有这一句，UI上不会显示 self.view.addSubview(mLabel) let mButton:UIButton=UIButton() mButton.frame=CGRect(x: 10, y: 80, width: 200, height: 50) mButton.backgroundColor=UIColor.redColor() mButton.setTitle(\"按钮\", forState: .Normal) mButton.setTitle(\"按钮按下\", forState: .Highlighted) //添加点击事件Selector(\"btnOnClick\") 对应函数 func btnOnClick() //mButton.addTarget(self, action: Selector(\"btnOnClick\"), forControlEvents: .TouchUpInside) //添加点击事件Selector(\"btnOnClick:\") 对应函数 func btnOnClick(button:UIButton) mButton.addTarget(self, action: Selector(\"btnOnClick:\"), forControlEvents: .TouchUpInside) self.view.addSubview(mButton) } //函数定义 func 开头 func btnOnClick(){ print(\"不带参数UIButton点击事件响应 1+1=\"+\"\\(sum(1, two: 1))\") mLabel.text=\"不带参数UIButton点击事件响应计算 1+1=\"+\"\\(sum(1, two: 1))\"; } //方法定义 func 开头，方法名是 btnOnClick，传的参数是一个UIButton func btnOnClick(button:UIButton){ print(\"UIButton点击事件响应 1+1=\"+\"\\(sum(1, two: 1))\") mLabel.text=\"UIButton点击事件响应计算 1+1=\"+\"\\(sum(1, two: 1))\"; } //参数传递和返回类型 传两个Int类型的参数，返回一个Int类型 //返回类型是在（）后面使用 -> func sum(one:Int,two:Int)->(Int){ return one+two } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. } }","tags":[{"name":"UIButton","slug":"UIButton","permalink":"http://www.veidy.net/tags/UIButton/"},{"name":"Selector","slug":"Selector","permalink":"http://www.veidy.net/tags/Selector/"}]},{"title":"swift学习笔记之UILabel","date":"2016-02-10T09:11:16.000Z","path":"2016/02/10/swift_01/","text":"一、知识点：1.UI控件的初始化2.字符串的拼接3.变量和常量的定义 二、效果图： 三、代码: class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. //常量定义用let 变量定义用var let mLabel:UILabel=UILabel(); //设置显示文字 字符串和字符串可以直接用+ 拼接，字符串和int 其它类型可以用 \\() 如下，把2016放在小括号里面即可 mLabel.text=\"veidy\"+\"开始了\\(2016)年的第一次swift 开发\" //设置label背景颜色 mLabel.backgroundColor=UIColor.redColor() //设置文字颜色 mLabel.textColor=UIColor.whiteColor() //设置文字剧中对齐 mLabel.textAlignment=NSTextAlignment.Center //定义坐标位置 label大小 mLabel.frame=CGRect(x: 0, y: 20, width: self.view.frame.size.width, height: 50) //添加到view 显示，没有这一句，UI上不会显示 self.view.addSubview(mLabel) }","tags":[{"name":"UILabel","slug":"UILabel","permalink":"http://www.veidy.net/tags/UILabel/"}]},{"title":"Android Studio 使用心得","date":"2016-01-21T02:19:41.000Z","path":"2016/01/21/android-studio/","text":"&nbsp; &nbsp;版权声明：本文出自veidy的博客，转载必须注明出处&nbsp; &nbsp; &nbsp;转载请注明出处：http://www.veidy.net/ &nbsp; &nbsp;之前在osc 上有整理一系列关于android studio 使用的文章 Android studio 使用心得(一)---android studio快速掌握快捷键 Android studio使用心得(二)--- 打包签名apk发布 Android studio 使用心得(三)---从Eclipse迁移到Android&nbsp; Android studio 使用心得(四)---android studio 多渠道打包 Android studio 使用心得(四)---android studio 多渠道打包(二) Android studio 使用心得(五)---代码混淆和破解apk Android studio 使用心得(六)---android studio 如何加载.so文件 Android studio 使用心得(七)---如何导入library工程包 Android studio 使用心得(八)----测试程序单元测试 Android studio使用心得(九)------如何设置项目编码 Android studio 使用心得(十)---android studio 多渠道打包(三)","tags":[{"name":"android","slug":"android","permalink":"http://www.veidy.net/tags/android/"},{"name":"studio混淆","slug":"studio混淆","permalink":"http://www.veidy.net/tags/studio%E6%B7%B7%E6%B7%86/"},{"name":"多渠道打包","slug":"多渠道打包","permalink":"http://www.veidy.net/tags/%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85/"}]},{"title":"(转)如何选择compileSdkVersion,minSdkVersion和targetSdkVersion","date":"2016-01-19T01:59:49.000Z","path":"2016/01/19/如何选择compileSdkVersion-minSdkVersion和targetSdkVersion/","text":"compileSdkVersion minSdkVersion targetSdkVersion 1.翻译原文:如何选择 compileSdkVersion, minSdkVersion 和 targetSdkVersion 2.英文原文：Picking your compileSdkVersion, minSdkVersion, and targetSdkVersion 3.Android targetSdkVersion 原理","tags":[{"name":"compileSdkVersion","slug":"compileSdkVersion","permalink":"http://www.veidy.net/tags/compileSdkVersion/"},{"name":"minSdkVersion","slug":"minSdkVersion","permalink":"http://www.veidy.net/tags/minSdkVersion/"},{"name":"targetSdkVersion","slug":"targetSdkVersion","permalink":"http://www.veidy.net/tags/targetSdkVersion/"}]},{"title":"2016 计划...","date":"2015-12-25T07:18:16.000Z","path":"2015/12/25/2016计划/","text":"2015还没来得总结，忙里偷闲想把2016博客上的内容规划一下.2014的时候有给2015规划过，然后。。。已经找不到那份规划文档… 2016 要整理的几个干货。。。 &nbsp; &nbsp; &nbsp;1.图片加载框架 &nbsp;Android-Universal-Image-Loader&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;2.图片加载框架 &nbsp;fresco &nbsp; &nbsp; &nbsp;3.orm 框架 &nbsp;GreenDao &nbsp; &nbsp; &nbsp;4.网络请求框架&nbsp;android-async-http &nbsp; &nbsp; &nbsp;5.网络请求框架&nbsp;okhttp &nbsp; &nbsp; &nbsp; 6.VRefreshView &nbsp; &nbsp; 基于google官方SpipeRefershLayout自定义的&nbsp;下拉刷新，上拉加载更多view. &nbsp; &nbsp; &nbsp; 7.VCycleViewPager 自定义ViewPager,可以用于引导页，轮播广告自动循环播放 &nbsp; &nbsp; &nbsp; 8.VRichTextEditText 自定义EditText ，可以图文混排显示和编辑 &nbsp; &nbsp; &nbsp; 9.VScrollViewContainer &nbsp;自定义View，效果就是现在很多商城APP图文详情那种，上拉查看图文详情 &nbsp; &nbsp; &nbsp; 10.&nbsp;VAsyncImageUpload &nbsp;通过使用线程池&nbsp;异步多张图片上传 &nbsp; &nbsp; &nbsp; ...待续","tags":[]}]